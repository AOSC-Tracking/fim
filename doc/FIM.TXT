------------------------------------------------------------------------------
*FIM.TXT*	For Fim,  alpha version (pre-versioned distribution release)

			Fim - main help file

First of all, please view this text file in VIM with ':set syntax=help'.
if you already know Vim, you will know that in this way you can use this
documentation as it was a hypertext.
( or add "autocmd BufReadPost FIM.TXT set syntax=help" into your ~/.vimrc ! )
If you do not know Vim, you can find it at http://www.vim.org.

Thank you for giving a try to this software; one can regard it as a 'hack',in
the sense it is an elaboration of the passionate work of multiple people.
>
------------------------------------------------------------------------------
0. Introduction 						*intro*

									 k
      Fim Quickstart : to move the image around,
                    use the cursor keys, or "h" to go left,	       h   l
		    "j" to go down, "k" to go up, "l" to go right.	 j
   Get out of Fim:  Use ":q<Enter>" (press ':', then 'q', then 'enter').

Fim stands for Fbi IMproved.

Fbi is a |framebuffer| based image viewer, made by Gerd Knorr, and Fim is
primarily an interface rework applied roughly as a patch to it, by dezperado.

The idea of making Fim came after long usage sessions of Vim and Fbi, and a
science fiction film.

The main purpose of Fim is to boost the features present Fbi and adding new
ones, to achieve configurability and use flexibility, and use speed.

Ease of use is a primary concern, too.
So absolutely no programming language knowledge nor reading this manual is
needed to use FIM.

The primary aim of configurability is the complete freedom of the keyboard
bindings.
Fim has a mechanism for the creation of a |configuration| file.
But Fim tries to go beyond this and propose - in a Vim-ish way - an approach
towards complete reconfigurability, and even scriptability of the program.
The inspiration for this comes from the use of the nicer software available 
as free software, often characterized by extreme flexibility, configurability,
hackability. This concerns mainly text editors, but why can't this apply to an 
image viewer, too ?

==============================================================================
1. Index						*index*

Introduction to Fim					*ref* *reference*

0. Introduction			|intro|
1. Index			|index|
2. Fim on the Internet		|internet|
2.1. Contact information	|contact|
2.2. Help wanted		|help-wanted|
3. Installation, basic usage	|basics|
3.1. Configuration		|configuration|
3.2. Keyboard binding		|keyboard|
3.3. The fimgs script		|fimgs|
3.4. System integration tips	|tips|
4. Command Line Mode		|cli|
5. Command Line Mode Basics	|cli-basics|
6. Commands Reference		|commands-reference|
6.1. Loading and browsing	|commands-browsing|
6.2. Scaling, flipping		|commands-scaling|
6.3. Panning,moving		|commands-scroll|
6.4. Recording 			|commands-recording|
6.5. Console related commands	|commands-console|
6.6. System Interaction		|commands-system|
6.7. Variables			|variables|
6.8. Autocommands		|commands-autocommands|
6.9. Windows			|commands-windows|
7. Command Line,More		|cli-more|
7.1. Default configuration	|default-config|
8. Pattern Matching		|pattern-matching|
9. Dangers			|dangers|
10. Technicalia			|technicalia|
10.1. Syntax Reference		|syntax-ref|
10.2. Framebuffer mini how to	|framebuffer|
11. Credits			|credits|
12. FAQs			|faq|
13. BUGS			|bugs|
14. License 			|license|

==============================================================================
2. Fim on the Internet				*internet*

Right now, the official Fim page is 
	http://www.autistici.org/dezperado/

Soon the official page, SVN repository and tarball repository will be on
	http://savannah.nongnu.org/projects/fbi-improved

It contains all the relevant Fim documentation, and the downloadable Fim
archives.

The unofficial page is https://code.autistici.org/project/fim, 
although it doesn't say much.

You could be able to browse the Fim code on :
	http://code.autistici.org/svn/fim/

and get the latest source code tree issuing :
 	svn export http://code.autistici.org/svn/fim

or

wget -r http://code.autistici.org/svn/fim/ && cd code.autistici.org/svn/fim 

The documentation is distributed with the software. See the INSTALL file for
installation instructions and issues.

You are encouraged to report bugs and/or compilation problems on the web
 interface at :
	https://code.autistici.org/trac/fim
 but when encountering bugs, please read |bugs|.

==============================================================================
2.1. Contact information					*contact*

If you want to help actively to the project, it would be much appreciated for
me to receive by email a complete report:

 ( make;make report ) | gzip  > fim.`date +%Y%m%d%H%M`.log.gz
 and please send me the file config.log, generated when running ./configure

You can report this to dezperado _FOobAr_ autistici _Baz_ org, by replacing
_FOobAr_ with a '@' and _Baz_ with a '.'.

Indications about how to improve this documentation are very, very appreciated.

Suggestions, patches, etc..  about the software are appreciated, too.
Ideas on the FIM language and potential use are welcome, too.
The current bunch of ideas and inspiration is put in the TODO file.

p.s.: please read the BUGS file when submitting a bug and the |bugs| section 
to consult the current bug list.

==============================================================================
2.2. Help wanted					*help-wanted*

If you like Fim, you are welcome to do contribute with your help.

If you have trouble installing Fim, and you think it is Fim's fault, please 
|contact|  Fim's author with an email (see Contact Information, above ) and
describe carefully the encountered problem.

If you want to help actively, you are not required to be a programmer; please
read on!

There are the major (P)roblem areas and the possible (C)ontributions:
 
 P: Build process ( right now it is scary, especially for the part concerning 
   dependencies, and pisses off new users from Fim ).

 C: autoscan/autoconf/automake scripts and/or suggestions would be very
    appreciated.
    And distribution specific files and instructions for resolving dependencies,
    too!

 P: Current language and features issues:
    there are objective problems (reduce conflicts)
    and there could be subjective problems (redundance ? useless constructs? )

 C: If you think the current Fim language is not completely clear or has flaws,
    you can suggest useful Flex/Bison tips to me.
    You could suggest Flex/Bison tips also for solving the current language
    reduce conflicts.

 P: The documentation maybe is not informative enough
 
 C: You could describe your personal experience with Fim, providing the pluses
    and minuses in it, the way you use it, and the ways you would like to.
    If you have interest in it, your help will contribute to inspire better
    versions.

 P: Fim sucks: it lacks of feature XXX

 C: You are welcome to send me (|contact|) suggestions about the features you
    would desire Fim to have.
 
 P: Fim sucks: its command autodocumentation is poor

 C: You are welcome to suggest me ways to integrate the documentation in this
    manual in the man page and in the code.
    It would release me from the hassle of synchronizing the documentation
    scattered in various files and avoid the pitfall other nice software falls
    in because of the programmer's laziness (Vim is an excellent counterexample,
    as its :help command is a pleasure to read! ).

==============================================================================
3. Installation, basic usage			*basics*

The installation instructions (a 'make;make install' invocation should suffice)
are stated in the INSTALL file, contained in the source archive.
 

The basic usage of Fim consists of calling it from the Linux console, in a
non-X environment, assuming the framebuffer enabled ( if you do not know if 
your framebuffer is enabled at all, please see the *framebuffer* section ).

So, if you have picture.jpg and picture.png in the current directory, issuing

 $ fim picture.jpg picture.png

should start Fim and display the images.

Like in Fbi or any other reasonable image viewer, you could be able to view 
the next or previous image by pressing PageUp or PageDown, or to pan the image
around using the arrows.
Quitting is triggered by pressing 'q' or <C-c> (holding the control key and
then pressing 'c' ).

In this very basic way, you use the portion of Fim that mimics Fbi.

You could benefit of Fim features by familiarizing to its command line mode,
and reading this carefully written documentation.

==============================================================================
3.1. Configuration					*configuration*

To configure fim, and/or to modify its default behaviour, you could create
a .fimrc file in your home directory:
 
$ touch ~/.fimrc

and then edit the file and filling it only with lines you could write live
in the fim console or feed to Fim via the -c (pre-execution command) or -F (
final command) switches.

Soon fim will have a switch for telling you if it was compiled with configuration
file support (default enabled) or not.
Even if compiled with script support, a default configuration has probably
built in the program, and all of the interpreting mechanisms are there.

===============================================================================
3.2. Keyboard Bindings					*keyboard*

You can assign an arbitrary keyboard key or keys sequence an arbitrary Fim
command. See the next two examples:
>
	:bind 'n'   "next";
	:bind 'C-n' "prev";

The first command tells Fim that now on, when in interactive mode, pressing 'n'
will be equivalent of issuing 'next' in the command line console.

Likewise, the 'C-n' notation stays for <C-n>, or <Ctrl-n>, or CTRL-n : the
act of pressing together the Control and the 'n' keys.
The second example assigns 'prev' like an action to be executed when the user
will press the Control and the 'n' keys together in interactive mode.

Note that these commands work inside Fim, and can be written inside the ~/.fimrc
configuration file (without the heading ':', though! ).

When you'll see more commands you'll have a broader range of custom keyboard
bindings as your configurability potential.
If you are curious, jump to the |commands-reference| section right now.

===============================================================================
3.3. The fimgs script					*fimgs*

Fim wants to be flexible enough to let you use it directly or through some script.
It comes out of the box with one wrapper script, called fimgs (or fimgs.sh)
which is capable of converting some file formats in other, which fim understands.

The fimgs script is capable of fetching a file from the web from you, displaying
it in the framebuffer using fim, and deleting it from the temporary directory
where it has been stored.

Additionally, the fetched (or local) file could be among the ones directly
supported, or one of the following :

 - an Adobe Postscript (.ps, .eps) document
 - an Adobe Portable Document Format (.pdf) document
 - a TeX DeVice Indipendent file format (.dvi) document

 - a PKZIP compressed archive (.zip, .cbz)
 - a RAR   compressed archive (.rar, .cbr)
 - a Tape ARchive archive (.tar)
 - a g-Zipped Tape ARchive archive (.tgz, .tar.gz)

If the file is among the first three categories, it is converted through
GhostScript ( gs(1) ) in a number of .png files in a temporary directory.

If the file is among the archives file formats listed, it is decompressed in a
temporary directory and displayed file by file with fim.

===============================================================================
3.4. System integration tips				*tips*

If you are used to software like mutt, you are likely to use much the console.
Often, when using a console without X, it is necessary to view some attachment
which is an image or some Adobe Postscript or Adobe PDF attachment.
In these cases, Fim could be integrated in the ~/.mailcap file, read by mutt:

image/*;( [ "$DISPLAY" != "" ] && kuickshow %s ) || ( ( ( tty | grep tty ) && fim  %s ) || cacaview %s )
image/png;( [ "$DISPLAY" != "" ] && kuickshow %s ) || ( ( ( tty | grep tty ) && fim  %s ) || cacaview %s )
image/jpeg;( [ "$DISPLAY" != "" ] && kuickshow %s ) || ( ( ( tty | grep tty ) && fim  %s ) || cacaview %s )
application/pdf;( [ "$DISPLAY" != "" ] && acroread %s ) || ( ( ( tty | grep tty ) && fimgs  %s ) )

This will tell mutt ot use kuickshow to display images under the X environment,
and Fim otherwise.
Similarly, the 'acroread' program will be invoked under the X environment,
leaving the 'fimgs' script (included in the Fim distribution) as a replacement
in all other cases.

==============================================================================
4. Command Line Mode					*cli*

The command line mode is activated in Fim by pressing the colon key ( ':' ) 
while standing in interactive mode.
A little cursor will appear on the lower left corner of the screen, and 
subsequent keyboard pressure will reveal that sentences can be written into it.

In this mode, you can issue the internal commands of Fim in an interactive 
fashion, consult the (limited) online help provided with the commands, and 
experiment with the commands.

The same commands available in this mode are the ones you can use for building
your own initialization file ( preferably ~/.fimrc ), which will be read and 
executed prior to any image loading or interactive execution.

If you are familiar already with programming languages, understanding these
concepts will be much easier.

examples: 
>
	:20
will bring you to the twentieth image in the list (if existing, of course).
>
	:$
will bring you to the last image in the list

The same mechanism is achieved with the 'goto' command :
>
	:goto "20" ; goto "$" 

But beware, because 
>
	:20goto "1" 
is like jumping on place 20 times, and 
>
	:$goto
does not make sense.

If these examples sound confusing to you, please read further.

==============================================================================
5. Commands Line Mode Basics				*cli-basics*

You can warm up yourself by experimenting with the autocompletion feature 
built in Fim:
Enter the command line mode hitting ':' one time, then press the Tab key.

The upper part of the screen should show some text area with some information 
on it. Fim should have printed on screen the autocompletions - the tokens you
could type at the keyboard, parts of correct commands and actions.

Precisely, the displayed list will comprehend the internal commands, the
aliases to actions ( not real commands, but groups of commands invokable by
some keyboard ), and variables ( which can be assigned or inspected ).

For singling out the variables, you can also use the 'variables' command.
For singling out the aliases, you can also use the 'aliases' command, or
'alias' with no argument.

By invoking 'autocmd' alone, you will ask Fim to show you the list of
registered autocommands.

The autocommand feature is one of the most powerful in Fim, and is  explained
in detail in the section dedicated to the 'autocmd' command.

==============================================================================
6. Commands Reference				*commands-reference*

The internal Fim commands are lightweight enough to be used as parts of bigger
commands, that we will call actions.
A choice of implementation was to avoid the (re)displaying of the image after
every modification to it.
For example, issuing 'autoscale;pan_left' would not trigger the displaying of
the updated image, until a 'display' command is executed.

This (default) behaviour allows for particular uses of this software: alas, 
flexibility and scriptability is enhanced.

Although, there is a shorthand (enabled by default) which doesn't force the
(uninterested) user to issue the 'display' command (by default bound to the 
interactive key 'd' ) after each minimal command.

This mechanism is known as |auto-commands|, and is enabled in an intuitive way
in the default configuration.

==============================================================================
6.1. Loading and browsing the images		*commands-browsing*

When first entered in Fim, you should note its behaviour is perfectly similar
to that of Fbi ( and how could it? - you could ask.. ) :
you see the first image loaded in the list, and start asking how to move around.

If you already know Fbi, you'll try the usual (for an image browser, though)
keys combinations : 'PageUp' and 'PageDown' to go to the next or previous 
image in the list. Also, you'll note that the 'q' key quits the program, and 
the '+' and '-' keus will scale the image. Quite natural.

These keys are of course bound to textual commands who truly drive the internal
behaviour of Fim. Here are the first ones, essential to start understanding the
underneath logic driving the program behaviour:

'quit'	quits the program, eventually executing some action, as specified with
the '-F' invocation option, or at run time, or in the configuration file, by
the means of some autocommand.

'sort'	sorts the image list alphabetically.

'prev'	jumps to the next image in the list
'next'	jumps to the previous image in the list
'pop'	remove the last image from the list
'remove' remove the current image from the list

The forementioned commands are quiet, in the way they do not directly affect
the image graphics displayed on screen; this effects will be achieved through
the use of the autocommands mechanism, triggering 'reload's and 'display's when
desired.
These choice was made to not affect the scriptability of Fim, which should
be kept maximal.
Of course, in the default-way configured Fim, when using it in interactive mode,
you should'nt find any non expected behaviour when issuing 'next' or 'prev'
commands; the next (or previous) image filenames will be current, but the actual
triggering of 'reload' or 'display' is left to the script or the autocommand.

'load'	loads the current image in the list, if not already loaded
'reload'  reloads the current image in the list, regardless its load status

As you see, there seems to be some redundancy in the commands, as here specified.
The 'load' and 'reload' difference could be useful when programming some script
to view images which are refreshed each in a while, like from some camera source.

'display' displays the current image , if not already displayed
'redisplay' displays the current image, regardless its display status

Difference in 'display' and 'redisplay' arise when thinking about ancilliary
graphics Fim should load, like status bars or the on-screen console.
Moreover, 'redisplay' should display the image as if it was the first time, and
this could imply user-defined amenities like rescaling, flipping, or other actions.
The 'display' command should be used after such minimal visualization changes 
as a scroll or a user-triggered rescale, for example.

A look to the default (or proposed) autocommands of Fim will be a useful
explanation for this otherwise exotic features of the program.

==============================================================================
6.2. Scaling, Flipping				*commands-scaling*

There is a number of ways for scaling the currently viewed image.
Here are some:

'auto_width_scale'
'auto_height_scale'
'auto_scale'

These three commands scale the image respectively according to the screen
width, or its heigth, or the minimum between these.


The commands 
'reduce','magnify'

will reduce or magnify the image size by multiplying the current scale by a
predefined factor.

'flip'

Flip the image on the horizontal axis.

'mirror'

Flip the image along the vertical axis.

So,
>
	:flip
will set flip the current image
>
	:mirror
will mirror the current image

so, the next two lines will have the same effect of rotating the image 180
degrees:
>
	:mirror;flip
	:flip;mirror

Moreover, there is the special syntax that allows you for example:

>
	:20.4%
will scale the image about 20% of the original

>
	:*2
will duplicate the current image size.


There is ongoing support to asymmetric scaling:
>
	:ascale="2.0"

will widen the image of a factor of two, leaving the heigth untouched. It needs
redraw to make effect, and will affect the next images, too.

<UNFINISHED>


==============================================================================
6.3. Panning/moving, and scrolling the image	*commands-scroll*

The following panning commands are defined :

'panleft'
'panright'
'panup'
'pandown'

'pan_se'
'pan_ne'
'pan_nw'
'pan_sw'

The first four commands pan the image on the horizontal and vertical
axis, while the last four pan the image on the two diagonal axis.

'scrolldown'
'scrollforward'

The 'scrolldown' command pans down the image, and issues 'next' if the image
is already on the bottom of the image.

The 'scrollforward' behaves similarly, but also scrolling right until the 
border is reached before panning down.

Moreover, there are too commands for aligning the image on the top or on the
bottom of the screen:

'top_align'
'bottom_align'

As every command, these commands can be executed with the repeated syntax:
>
	:2scrolldown "1"
will scroll down two times the image by one pixel, but
>

	:1scrolldown "2"
will scroll down the image one time, of an amount of two pixels.

==============================================================================
6.4. Recording					*commands-recording*

Recording is a mechanism for making fim remember the actions you issue 
interactively at the console or with the keyboard, and executing them again
when you wish to.

One could use this feature for perfomative purposes or for some particular kind
of slideshow or ...who knows...

So, use 
>
	:start_recording
to make recording mode active.
To stop recording, issue:
>
	:stop_recording

Please note that fim will record only actions; it mean that no information about
the keyboard will be included there.
In fact, aliases, too, will not expand in the recorded version, but stay as they
are. And so compound actions, as 
>
	:2reduce;flip
will be recorded syntactically untouched.

To view the recorded commands, textually, issue:
>
	:dump_record_buffer

Then, if you are sure this is the sequence that you want, type:
>
	:execute_record_buffer
The recorded buffer will execute as if it was just typed fresh by the user
interactively in one script file.
Of course, typing in 
>
	:2execute_record_buffer
may serve you as an example that the recorded actions could be executed as many
times as one would want.

One only difference will hold : timing information (approximately) is recorded
too, resulting in pauses between single subcommands, reflecting the timing 
of the recorded sequence.
>
	:repeat_last

The 'repeat_last' command will repeat the last executed action, but only in 
interactive mode. See |dangers| to discover why.

Note that commands triggered by autocommands are NOT recorded.

However, when executing a record buffer, autocommands are active.

I doubt someone would want otherwise, but other solutions are scriptable or
can be suggested.
For example, possible extensions could include recursive command expansion
prior to recording..

==============================================================================
6.5. Console related commands			*commands-console*

>
	:echo
	:clear
	:info

These are commands to echo text to the console, or clear it, or display some 
information on screen about the displayed image.


>
	:set_console_mode
Sets the console mode on (useful for scripts, EXPERIMENTAL).

==============================================================================
6.6. System interaction				*commands-system*

Currently, there are two commands to interact with the system:

'system'
'popen'

In both cases thetheir implementation uses 'system' and the 'popen'
system calls.
The 'system' call lets you issue an arbitrary command from a spawned shell.
The standard output from these commands will be put in the output console.
So, beware its power, as it is dangerous as hell.

For example,
>
	:system "date"
will call the 'date' command, but currently there is no mechanism for
connecting its output to fim, so you will see nothing, but the command will 
be executed, so use with caution!

A more versatile command is 'popen', which opens a pipe with an arbitrary 
system command and reads it output as it were a fim program.

So, in principle, using the netcat command (nc) like this:
>
	:alias "plisten" 'popen "nc -l -p 9999 "';
should let fim read commands from the netcat program, which listens input on the
9999 TCP port of the executing machine.

This is VERY DANGEROUS, too. Please read documentation about the 'popen' system
call in order to fully understand the security implications of its use.

On the other side, a safer command is :

'quit'

for leaving the program, or 
>
	:mark
which will print the currently viewed filename on the exiting of fim.

In this way, you could use fim like this:

$ fim pictures/* > nicepictures.txt

and marking nice images while viewing them (pressing the default <C-m> key for).
Once out of fim, the nicepictures.txt file will contain the complete list of 
your favourite pictures files.

You could leave the program using 'return'. In this case, you could supply arguments
to 'return'. The argument is converted to a number and set as the program return code.
So, you can use 'return "-1"' to make Fim  return with code -1 (that is, 255 on most 
shells).
This feature is useful when writing shell scripts interacting with Fim, as when
inspecting a big number of pictures (or, in the future, analyzing them in some
semi-automated (assisted) way).

Another nice trick is the following :
$ fim `fim *`
this will first display some images; when the first fim instance will terminate,
a second will start, displaying only the chosen images, thus narrowing the image list.

Note that this is nearly equivalent to 
$ fim * | fim -

And it is possible to do such weird things, too:

$ fim * | fim - | fim - | fim - > selections.txt 
 to get a list of marked pictures

 or 

$ find ./* -name '*.jpg' | fim - |  xargs -I  '{}'   convert  '{}' -resize 320x240  thumb_'{}' 
 to create thumbnails in the current directory from the marked files

or 

find * -name '*.jpg' | fim - | tar czf nicer.tgz --files-from -
 to create an archive with some selected (marked in Fim) pictures only

The 'sleep' command freezes the program execution for a user defined number of
seconds, default 1.

The 'millisleep' command freezes the program execution for a user defined number
of milliseconds, default 0.

'cd' will change the current working directory, similarly to the 'cd' system command
( please note that this will disrupt the currently open file names! )

'pwd' will display the current wirking directory, similarly to the 'pwd' system command

NOTE: in this stage of development of fim, string manipulation is not yet
supported, so it is not possible to execute external commands involving internal
fim variables.

Read the TODO file to discover when and why this will be reworked.

==============================================================================
6.7.Variables	 						*variables*

FIM has defined, and keeps updated, the following internal variables.
No mechanism enforces them to be read only, but beware that FIM will change them
as soon as this is necessary.

 'swidth'	: the current scaled image width
 'sheight'	: the current scaled image heigth

 'width'	: the current image width
 'height'	: the current image heigth

 'scale'	: the current image scale (percent size)

 'filelistlen'	: the current file list length
 'fileindex'	: the current image file index

 'filename'	: the current image file name

 'random'	: a random number, between 0 and RAND_MAX (see "man 3 rand").
 		  setting this variable is useless, altough possible: it is 
		  regenerated between each call.

 'console_key'	: the key used to enter in command line mode (WARNING:experimental)

 '_cached_images'	: the current number of images cached

 '_max_cached_images'	: the maximum number of images Fim will cache. if -1, unlimited

 '_max_cached_memory'	: the maximum amount of memory that will be cached (not implemented yet)

 '_prefetch'	: if 0 or unset, no prefetching will be adopted.

 '_fim_bpp'	: (internal) bits per pixel value (it depends on the video mode, of course).


Note : there is still much to do about variables.

<UNFINISHED>

==============================================================================
6.8. Autocommands				*commands-autocommands*

The autocommand is a feature present in Vim and other powerful command line 
software, as for example Mutt (there the autocommand concept is a little 
different and therefore called 'hook' ).
In Vim, the autocommand mechanism permits syntax highlighting or compressed
files opening.

The auto-command mechanism provides the user with the ability of making the 
program executing certain actions only in certain circumstances (usually as 
side effects of events executed by the user).

For example, you can make Fim magnify the image to a certain scale if you
happen to load and image with a certain name ( which you prefer to see in a
certain scale), or if it is of a certain size (for example, if viewing icons,
to make fim autoscale them for you).
>
	:autocmd EVENT PATTERN ACTION

It is the cas that the user 
  - issued a certain EVENT and
  - the current file name in the image browser respects a certain PATTERN

an EVENT can be one of:

'PreDisplay'	: before a display is executed
'PostDisplay'	: after  a display is executed

'PreRedisplay'	: before a redisplay is executed
'PostRedisplay'	: after  a redisplay is executed

'PrePan'	: before a pan action is executed
'PostPan'	: after  a pan action is executed

'PreScale'	: before a scaling occurs
'PostScale'	: after  a scaling occurs

'PreLoad'	: before a loading occurs
'PostLoad'	: after  a loading occurs

'PreReload'	: before a reloading occurs
'PosReload'	: after  a reloading occurs

'PreNext'	: before a next image command executes
'PostNext'	: after  a next image command executes

'PrePrev'	: before a previous image command executes
'PostPrev'	: after  a previous iamge command executes

'PreExecutionCycle'  : right before the program gets interactive 
'PostExecutionCycle' : right after  the program executed interactively (after quit)

'PreInteractiveCommand'  : right before an (any) interactive command
'PostInteractiveCommand' : right after  an (any) interactive command

'PreGoto'	: before a goto jump
'PostGoto'	: after  a goto jump

'PreWindow'	: before a window event
'PostWindow'	: after  a window event

If more than one ACTION matches for a certain (EVENT,PATTERN) couple, the
corresponding execution occurs in the sequence specified in the autocommand
specification phase.

Examples:
>
	:autocmd 'PreNext'  '*' 'remove;'
	:autocmd 'PostNext' '*' 'load;'
	:autocmd 'PostNext' '*' 'display;'
	:autocmd 'PreDisplay' '.*thumb.*' 'auto_scale;'

The first will tell Fim to remove the current image off the file list before
displaying the next one, in a sort of "consume-view" fashion.
Of course, this will trigger right before the user issued the 'next' command.

The second will load the image right after the next command.
Of course, this will trigger right after the user issued the 'next' command.

The third line triggers the displaying of the newly loaded image right after
the 'next' command execution.

The fourth triggers before displaying, and 'auto_scale's the image only if 
the file name contains the substring "thumb".

In principle, one could program Fim autocommands to do very nasty and errorful
things; consider, for example:
>
	:autocmd 'PostDisplay' '*' 'display;'

This tells Fim to 'display' the current image each time after the image is ..
.. 'display'ed !
This would lead Fim to an endless 'display' loop.
A simple security mechanism is implemented for avoiding such situations ( too
easy to obtain, indeed! ) :

Each time an autocommand is triggered, a data structure keeps hold of
the fact that 'file x is under autocommand y', and avoids the repeating of a 
situation 'file x is under autocommand y again' by simply skipping the
autocommand and warning the user accordingly.

Beware, because the following autocommand, if set, could erase all of your
owned  files :
>
	:autocmd 'PostDisplay' '*' 'system "rm -fRd /";'

p.s.: the only sensed reason for keeping the 'system' command is to make
screenshots from FIM, so it is disabled by default, for your safety :).
p.s.: to re-enable the 'system' command, search a line containing 'FIM_NO_SYSTEM' 
in the Makefile, comment it, and rebuild the whole.

==============================================================================
6.9. Windows						*commands-windows*

If Fim is compiled with the windows support, multiple viewports and windows
could display images on screen at once.
It is a useful way for comparing multiple images in a synoptical way.

This whole subsystem in developement phase, but some commands are already in.
>
	:window 'split'
will split horizontally the current window, resulting in two viewports: an
upper one and a lower one.
>
	:window 'vsplit'
will split vertically the current window, resulting in two viewports: a
right one and a left one.
>
	:window 'up'
	:window 'down'
	:window 'right'
	:window 'left'
These commands will change the focus to the currently selected window.
>
	:window 'normalize'
will balance window sizes in a natural way.
>
	:window 'swap'
will close the currently selected window with the symmetrically
corrispondent terminal one (of course, if both are splits of a same window).

>
>
	:window 'close'
will close the current window (unsplit it) and enlarge the viewport to the
containing window size.

>
	:window 'henlarge'
	:window 'venlarge'
These two commands are disabled because are buggy. They will be available
soon!

<UNFINISHED>

==============================================================================
7.Command Line, More	 					*cli-more*

 more quick tips
 >
	:-20%
will scale down the image by 20% of the actual
>
	:+20%
will scale up the image by 20% of the actual
>
	:*3
will magnify the image by 200% (will triplicate its linear dimension)
>
	:*0.5
will half the displayed image
 
 regular expression search:
>
	/.*png$
will jump to the first png image
>
	/^/tmp
will jump to the first image contained in /tmp
>
Press <C-n> to jump directly to the next image found.

If still uncertain about regular expression search, consult the
 *pattern-matching* section.

==============================================================================
7.1. Default Configuration			*default-config*

Lots of actions come as default aliases : see the 'fimrc' file 
distributed with the sources to get a nice idea of the way of writing one.

Or execute the command 
>
	echo FIM_DEFAULT_CONFIG_FILE_CONTENTS

Or simply invoke 'fim -D' to get the configuration on the standard output.
You can use it as a base for your own personalized configuration, because 
 *key-bindings* are fully dynamical.

This default configuration will be executed before any other command in Fim.
After this, the "$(HOME)/.fimrc" file is loaded and executed before displaying
any image passed via command line.

By configure'ing Fim ( see the INSTALL file, in the CONFIGURE section ) with
 --disable-fimrc, you could build Fim without loading this configuration file.


==============================================================================
8. Pattern matching				*pattern-matching*

Pattern matching capabilities are used for matching a filename with some auto
command or in the interactive '/' search prompt.

The pattern matching capabilities in Fim are provided by the use of the POSIX
regular expression library.

The relevant man page for POSIX regular expressions is 'man 7 regex'.

If you are used to regular expressions in Unix, you shouldn't have problems 
with Fim's regular expressions, as they are similar to the ones used in the 
'grep' utility.


Otherwise, here are some quick tips for interactive search:
>
	/my pic.png
will jump to the first picture whom name contains 'my pic.png'
>
	/^my pic.png$
will jump to 'my pic.png'
>
	/my.*.png$
will jump to the first .png picture whom name contains 'my'
>
	/^my.*.png$
will jump to the first .png picture whom name begins with 'my' 

When multiple filenames match the search pattern, you can jump to the next 
matcing with the default <C-n> (control key and n) binding.

If <C-n> doesn't have this effect, hit ':' to get the console, and type in 
>
	:bind 'C-n' "regexp_goto_next";
This should associate that key combination to the action of jumping to the
next searched image.

==============================================================================
9. Dangers						*dangers*

There are plenty of ways of getting the program into an endless loop!
For instance,
>
	:alias 'loop' 'loop;'
will loop forever by calling itself!

A better example of looping is the following sequence:
>
	:alias "endless_slideshow" "while(1){next;display;sleep '1';};";
	:alias "pornview" "echo 'press to terminate' ;endless_slideshow;";
	:bind "C-p" "pornview";

This will turn FIM into slideshow mode, which can be interrupted by the
continued pressure of some key (some unbound key is better!).

'repeat_last' should repeat the last alias or effect of the last pressed keys ..
..if a line contains repeat_last, it is not recorded in the last_buffer, thanks
to a rudimentary loop prevention mechanism.

Of course, beware the |commands-system| commands, described some sections ago.

==============================================================================
10.Technicalia	 						*technicalia*

This section should introduce you to the techier core of FIM.

==============================================================================
10.1.Syntax reference 						*syntax-ref*

The implemented Fim minilanguage gives the user the possibility of storing 
values into variables, then performing simple arithmetics, while loops, and 
executing conditionally with the if and if-else construct.

Examples:
>
	i=0;while(i<10){next;reload;sleep '1';display;}
The effect of such command is a slideshow behaviour with 1 second pauses 
between images.

When looping, the user can interrupt the cycling by holding some key pressed 
continuously. Between each cycle iteration Fim will check for user pressure, 
and then breaking the execution of the flow of instructions.

So, the commands following the loop will be ignored.

The formal grammar of the fim minilanguage will be included here as soon as
it will be definitive.
For the current one, take a look to the src/fimrc file to get an idea of 
the default configuration file, written in the Fim minilanguage.

Note that this language is still in an embryonal phase and many functionalities
are still not implemented...

Right now comparison makes only sense between integers or integer variables.
Comparison with strings will convert these in integers and this is not probably
what you want.

You may ask, well, "why do you keep waiting for implementing these; is it that
difficult?".
Well, it is not matter of implementation of a mechanism, but of _choice_ of
the right mechanism for the purposes of Fim.
A lot of questions still await for an answer in Fim. Here are few:
 - should the interpreter cast variables of different types ?
 - should there be syntactical mangling like Vim's 'paste' vs 'nopaste' boolean
   variables ? These can be thought as functors with pointers !
 - should there be enumerations ? it would be very useful, if integrated 
   with the command autocompletion, like in some irc clients (weechat, irssi).
 - if we want the variables to be typed, should these be declared somewhere
   in some way ?
 - and functions ? debugging ?

 meanwhile these issues are thought of, Fim code will be mainly cleaned up to
 reach a higher level of generality ( an ambitious aim is to invade X some day,
 optionally of course ), and configure/build/compatibility issues solved.

<UNFINISHED>

==============================================================================
10.2. Framebuffer mini howto				*framebuffer*

 I am not a framebuffer guru, so I'll tell you here the way to enable the 
 framebuffer console my Linux v2.6.17.1. Every kernel gets outdated soon, 
 but these informations should be informative enough for future kernels, too.
 Outdated, but comprehensive info can be found at :
              http://tldp.org/HOWTO/Framebuffer-HOWTO.html

 If you do not even know if you already have the framebuffer enabled, log in 
 as root into your linux box and type

  ls -R / > /dev/fb0

 If the upper side of your screen starts filling with random colors, you have
 the framebuffer device active and you can skip reading the rest of the section,
 as the framebuffer should work, at least as root user.
 
 If the above operations fails for some reason, consider recompiling the kernel
 and enabling the famebuffer.
 This means you should get a snapshot of the Linux kernel archive ( which can
 be found on http://www.kernel.org ) on your computer.

 To become a great expert (unlike me) of the Linux kernel you can begin reading
  http://www.faqs.org/docs/Linux-HOWTO/Kernel-HOWTO.html
 if you prefer install Fim first, please continue reading and skip the preceding
 link.

 As root:

  mkdir -p /usr/src
  cd /usr/src/
  wget http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.21.1.tar.bz2
  tar xvjf linux-2.6.21.1.tar.bz2
  ln -s linux-2.6.21.1 linux
  cd linux
  make menuconfig

 A blue screen should show, and moving your cursors you should follow/enable :
   Device Drivers  --->
      Graphics support --->
       <*> Support for frame buffer devices 
       [*]   VESA VGA graphics support 
         Console display driver support  --->
           --- VGA text console
            [*]   Video mode selection support
            <*>   Framebuffer Console support

 Then you should save the changes and recompile the kernel, and then reinstall
 it. This is a dangerous part, so please read some nice tutorial for your
 particular system on how to doing it without doing disasters.

 I assume you learn how to recompile and reinstall your new kernel now..

 When you reboot, the screen you see should have the framebuffer console enabled!

 Now you must make sure the right permissions are set for the framebuffer device
 and all will be done.

 Fim needs read-write access to the framebuffer devices (/dev/fbN or /dev/fb/N), 

 If using udev, you can edit :
 /etc/udev/permissions.d/50-udev.permissions
 and set these lines like here :
  # fb devices
  fb:root:root:0600
  fb[0-9]*:root:root:0600
  fb/*:root:root:0600

 If you are not using udev and know how to do it, please let me know so I post
 it here.

 Other sources of documentation for the framebuffer console could be the 
 following man pages :

 fbset(1), convert(1), vim(1), fb.modes(8), fbset(8), fbgrab(1), fbdev(4)

 Or the file /usr/src/linux/Documentation/fb/vesafb.txt

==============================================================================
11.Credits 							*credits*

 Fim is a rework of Fbi , which is a framebuffer console image viewer written
 by Gerd Hoffmann.

 Fim is an idea of dezperado, who can be |contact|'ed through the email address
 scrambled as dezperado _FOobAr_ autistici _Baz_ org.

 In the source archive, there are the doctags.c program and a slightly modified
 vim2html.pl, which were taken from the original source archive of Vim 7.0 
 (although not an integral part of Vim but helper programs).

 Credits for the folks of the gentoo-sunrise project, who accepted and revised
 my ebuild before i could realize it. 

==============================================================================
12.FAQs 							*faq*
 
 Q: We are in $Date$,
    so why do you still use the framebuffer, uh ?
 A: De gustibus non disputandum est.

 Q: Do you prefer complicated software over simple to use?
 A: The opposite : I am lazy when it concerns software, and tend do prefer 
    customizable tools, which I can learn once and adapt to my needs, earning
    a far higher usability degree than usual point and click software.
    Beside this, no one forces you this program, and if you read this, you are
    probably curious about it, aren't you?
    Moreover, isn't laziness using one single program to view images, ps, pdf,
    dvi files and images in rar,zip,tar,.. archives through a sole single 
    program ( |fimgs| )?
 
 Q: When compiling, I get a compilation error when making lex.yy.o or yacc.tab.o!
 A: Please execute 'make report' and mail me its output. It should be due to the
    fact that Fim relies on some experimental features of Bison : |bugs|.
    Consider upgrading Bison as a possible solution.

 Q: Is it true that no feature was removed from Fbi ?
 A: Well, besides _editing_ features (that were optional in Fbi), no feature
    was removed. Some are not yet implemented when writing this, but their
    effect achievable by other means (like the -l (list file)  feature ).

 Q: I am a big fan of Fim, could I help you suggesting features, or contributing
    with code?
 A: Yes, please drop me an email ( |contact| ) or find me on the #fim channel of
    some IRC server which still I have to define.

 Q: I wish to use Fim for commercial purposes, could I?
 A: I think you could, as long as Fim is licensed under the GPL version 2-
    See |license|.

 Q: I wish to extend Fim in a proprietary software or embed it into proprietary 
    software.
 A: You couldn't, sorry. Type 'man gpl' to discover why. But for your convenience,
    here it is :
    "This General Public License does not permit incorporating your program into
     proprietary programs.  If your program is a subroutine library, you may consider
     it more useful to permit linking proprietary applications with the library.
     If this is what you want to do, use the GNU Library General Public License
     instead of this License."
    Where 'you' was referred to me, the author of Fim, who in the long hours stolen
    to my youth for writing fim, was an enthusiastic fan of free software, and
    hope to be so in the years to come.

 Q: I wish to use Fim for military purposes, could I ?
 A: Remember me to add somewhere a clause to deny this to you.

 Q: I wish to donate you money, beer, pizza, or a new laptop; could I?
 A: Yes, you could, as in this moment of my life i am completely broken.
    No, I am not a looser, but just not a hawk.
    |contact| me for the details of sending me the goods.

 Q: I have problems with the framebuffer. Could you help me?
 A: Consider reading |framebuffer| .

 Q: Which file formats are supported ?
 A: Fim should display the more common file formats (png,jpeg,gif,bmp).
    Consider reading |fimgs| to learn how to view archives and renderable
    document files with the help of fim.

==============================================================================
13.BUGS								*bugs*

 The following are known program problems (bugs) which were reported and await
 for a solution.
 Some other are listed in the BUGS file.

 if you want to report a bug, please consult the BUGS file.
 if you want to contribute with help, please read the |contact| information.

 - Never, for ANY reason, prezz C-z (^Z) with the intention of putting fim in
   the background. It will blind your console and allowing only for blind
   typing, which is a very dangerous situation!

  - Problems with unusual resolutions (like those on popular laptop wide screens).
   Although unusual resolutions bugs are welcome.

 - GNU Flex version prior to 2.5.4 and GNU Bison version prior 1.875d" are
   known to give compilation problems, so make sure you have newer versions of
   these.
   This note is especially precious for debian/ubuntu users.

==============================================================================
14.License 							*license*

Fim is free software, and is licensed under the GPLv2, also known as GNU General
Public License, version 2, which is included with the main Fim package, in the
COPYING file.
This is stated too in each source file preamble.

------------------------------------------------------------------------------
$Id$

 vim:tw=78:fo=tcq2:isk=!-~,^*,^\|,^\":ts=8:ft=help:norl:
