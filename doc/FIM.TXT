------------------------------------------------------------------------------
*FIM.TXT*	For Fim version 0.1 (alpha).

			Fim - main help file (UNDER DEVELOPEMENT)

First of all, please view this text file in VIM with ':set syntax=help'.
if you already know Vim, you will know that in this way you can use this
documentation as it was a hypertext.
( or add "autocmd BufReadPost FIM.TXT set syntax=help" into your ~/.vimrc ! )
If you do not know Vim, you can find it at http://www.vim.org.

Thank you for giving a try to this software; one can regard it as a 'hack',in
the sense it is an elaboration of the passionate work of multiple people.
>
------------------------------------------------------------------------------
0. Introduction 						*intro*

									 k
      Fim Quickstart : to move the image around,
                    use the cursor keys, or "h" to go left,	       h   l
		    "j" to go down, "k" to go up, "l" to go right.	 j
   Get out of Fim:  Use ":q<Enter>" (press ':', then 'q', then 'enter').

Fim stands for Fbi IMproved.

Fbi is a |framebuffer| based image viewer, made by Gerd Knorr, and Fim is
primarily an interface rework applied roughly as a patch to it.
The idea of making Fim came after long usage sessions of Vim and Fbi.

The main purposes of Fim is to boost the features present Fbi and adding new
ones, to achieve configurability and use flexibility. 

The primary aim of configurability is the complete freedom of the keyboard
bindings.
Fim has a mechanism for the creation of a |configuration| file.
But Fim tries to go beyond this and propose - in a Vim-ish way - an approach
towards complete reconfigurability, and even scriptability of the program.
The inspiration for this comes from the use of the nicer software available 
as free software, often characterized by extreme flexibility, configurability,
hackability. This concerns mainly text editors, but why can't this apply to an 
image viewer, too ?

==============================================================================
1. Index						*index*

Introduction to Fim					*ref* *reference*

0. Introduction			|intro|
1. Index			|index|
2. Fim on the Internet		|internet|
3. Installation, basic usage	|basics|
3.1. Configuration		|configuration|
3.2. Keyboard binding		|keyboard|
4. Command Line Mode		|cli|
5. Command Line Mode Basics	|cli-basics|
6. Commands Reference		|commands-reference|
6.1. Loading and browsing	|commands-browsing|
6.2. Scaling, flipping		|commands-scaling|
6.3. Panning,moving		|commands-scroll|
6.4. Recording 			|commands-recording|
6.5. Console related commands	|commands-console|
6.6. System Interaction		|commands-system|
6.7. Variables			|variables|
6.8. Autocommands		|commands-autocommands|
7. Command Line,More		|cli-more|
7.1. Default configuration	|default-config|
8. Pattern Matching		|pattern-matching|
9. Dangers			|dangers|
10. Technicalia			|technicalia|
10.1. Syntax Reference		|syntax-ref|
10.2. Framebuffer mini how to	|framebuffer|
11. Credits			|credits|
12. FAQs			|faq|

==============================================================================
2. Fim on the Internet				*internet*

As of now, the official Fim page is https://code.autistici.org/project/fim, 
although it doesn't say much.
http://www.autistici.org/dezperado/fim contains FIM documentation, too.

You could be able to browse the Fim code on :
	http://code.autistici.org/svn/fim/
and get the latest source code tree issuing :

 	svn export http://code.autistici.org/svn/fim

or

wget -r http://code.autistici.org/svn/fim/ && cd code.autistici.org/svn/fim 

The documentation is distributed with the software.

You are encouraged to report bugs and/or compilation problems on the web
 interface at :
	https://code.autistici.org/trac/fim

If you want to help actively to the project, it would be much appreciated for
me to receive by email a more complete report:

 ( make;make report ) | gzip  > fim.`date +%Y%m%d%H%M`.log.gz

You can report to dezperado _FOobAr_ autistici _Baz_ org, by replacing _FOobAr_
with a '@' and _Baz_ with a '.'.

==============================================================================
3. Installation, basic usage			*basics*

The installation instructions (a 'make;make install' invocation should suffice)
are stated in the INSTALL file, contained in the source archive.
 

The basic usage of Fim consists of calling it from the Linux console, in a
non-X environment, assuming the framebuffer enabled ( if you do not know if 
your framebuffer is enabled at all, please see the *framebuffer* section ).

So, if you have picture.jpg and picture.png in the current directory, issuing

 $ fim picture.jpg picture.png

should start Fim and display the images.

Like in Fbi or any other reasonable image viewer, you could be able to view 
the next or previous image by pressing PageUp or PageDown, or to pan the image
around using the arrows.
Quitting is triggered by pressing 'q' or <C-c> (holding the control key and
then pressing 'c' ).

In this very basic way, you use the portion of Fim that mimics Fbi.

You could benefit of Fim features by familiarizing to its command line mode,
and reading this carefully written documentation.

==============================================================================
3.1. Configuration					*configuration*

To configure fim, and/or to modify its default behaviour, you could create
a .fimrc file in your home directory:
 
$ touch ~/.fimrc

and then edit the file and filling it only with lines you could write live
in the fim console or feed to Fim via the -c (pre-execution command) or -F (
final command) switches.

Soon fim will have a switch for telling you if it was compiled with configuration
file support (default enabled) or not.
Even if compiled with script support, a default configuration has probably
built in the program, and all of the interpreting mechanisms are there.

===============================================================================
3.2. Keyboard Bindings					*keyboard*

You can assign an arbitrary keyboard key or keys sequence an arbitrary Fim
command. See the next two examples:
>
	:bind 'n'   "next";
	:bind 'C-n' "prev";

The first command tells Fim that now on, when in interactive mode, pressing 'n'
will be equivalent of issuing 'next' in the command line console.

Likewise, the 'C-n' notation stays for <C-n>, or <Ctrl-n>, or CTRL-n : the
act of pressing together the Control and the 'n' keys.
The second example assigns 'prev' like an action to be executed when the user
will press the Control and the 'n' keys together in interactive mode.

Note that these commands work inside Fim, and can be written inside the ~/.fimrc
configuration file (without the heading ':', though! ).

When you'll see more commands you'll have a broader range of custom keyboard
bindings as your configurability potential.
If you are curious, jump to the |commands-reference| section right now.

==============================================================================
4. Command Line Mode					*cli*

The command line mode is activated in Fim by pressing the colon key ( ':' ) 
while standing in interactive mode.
A little cursor will appear on the lower left corner of the screen, and 
subsequent keyboard pressure will reveal that sentences can be written into it.

In this mode, you can issue the internal commands of Fim in an interactive 
fashion, consult the (limited) online help provided with the commands, and 
experiment with the commands.

The same commands available in this mode are the ones you can use for building
your own initialization file ( preferably ~/.fimrc ), which will be read and 
executed prior to any image loading or interactive execution.

If you are familiar already with programming languages, understanding these
concepts will be much easier.

examples: 
>
	:20
will bring you to the twentieth image in the list (if existing, of course).
>
	:$
will bring you to the last image in the list

The same mechanism is achieved with the 'goto' command :
>
	:goto "20" ; goto "$" 

But beware, because 
>
	:20goto "1" 
is like jumping on place 20 times, and 
>
	:$goto
does not make sense.

If these examples sound confusing to you, please read further.

==============================================================================
5. Commands Line Mode Basics				*cli-basics*

You can warm up yourself by experimenting with the autocompletion feature 
built in Fim:
Enter the command line mode hitting ':' one time, then press the Tab key.

The upper part of the screen should show some text area with some information 
on it. Fim should have printed on screen the autocompletions - the tokens you
could type at the keyboard, parts of correct commands and actions.

Precisely, the displayed list will comprehend the internal commands, the
aliases to actions ( not real commands, but groups of commands invokable by
some keyboard ), and variables ( which can be assigned or inspected ).

For singling out the variables, you can also use the 'variables' command.
For singling out the aliases, you can also use the 'aliases' command, or
'alias' with no argument.

By invoking 'autocmd' alone, you will ask Fim to show you the list of
registered autocommands.

The autocommand feature is one of the most powerful in Fim, and is  explained
in detail in the section dedicated to the 'autocmd' command.

==============================================================================
6. Commands Reference				*commands-reference*

The internal Fim commands are lightweight enough to be used as parts of bigger
commands, that we will call actions.
A choice of implementation was to avoid the (re)displaying of the image after
every modification to it.
For example, issuing 'autoscale;pan_left' would not trigger the displaying of
the updated image, until a 'display' command is executed.

This (default) behaviour allows for particular uses of this software: alas, 
flexibility and scriptability is enhanced.

Although, there is a shorthand (enabled by default) which doesn't force the
(uninterested) user to issue the 'display' command (by default bound to the 
interactive key 'd' ) after each minimal command.

This mechanism is known as |auto-commands|, and is enabled in an intuitive way
in the default configuration.

==============================================================================
6.1. Loading and browsing the images		*commands-browsing*

When first entered in Fim, you should note its behaviour is perfectly similar
to that of Fbi ( and how could it? - you could ask.. ) :
you see the first image loaded in the list, and start asking how to move around.

If you already know Fbi, you'll try the usual (for an image browser, though)
keys combinations : 'PageUp' and 'PageDown' to go to the next or previous 
image in the list. Also, you'll note that the 'q' key quits the program, and 
the '+' and '-' keus will scale the image. Quite natural.

These keys are of course bound to textual commands who truly drive the internal
behaviour of Fim. Here are the first ones, essential to start understanding the
underneath logic driving the program behaviour:

'quit'	quits the program, eventually executing some action, as specified with
the '-F' invocation option, or at run time, or in the configuration file, by
the means of some autocommand.

'sort'	sorts the image list alphabetically.

'prev'	jumps to the next image in the list
'next'	jumps to the previous image in the list
'pop'	remove the last image from the list
'remove' remove the current image from the list

The forementioned commands are quiet, in the way they do not directly affect
the image graphics displayed on screen; this effects will be achieved through
the use of the autocommands mechanism, triggering 'reload's and 'display's when
desired.
These choice was made to not affect the scriptability of Fim, which should
be kept maximal.
Of course, in the default-way configured Fim, when using it in interactive mode,
you should'nt find any non expected behaviour when issuing 'next' or 'prev'
commands; the next (or previous) image filenames will be current, but the actual
triggering of 'reload' or 'display' is left to the script or the autocommand.

'load'	loads the current image in the list, if not already loaded
'reload'  reloads the current image in the list, regardless its load status

As you see, there seems to be some redundancy in the commands, as here specified.
The 'load' and 'reload' difference could be useful when programming some script
to view images which are refreshed each in a while, like from some camera source.

'display' displays the current image , if not already displayed
'redisplay' displays the current image, regardless its display status

Difference in 'display' and 'redisplay' arise when thinking about ancilliary
graphics Fim should load, like status bars or the on-screen console.
Moreover, 'redisplay' should display the image as if it was the first time, and
this could imply user-defined amenities like rescaling, flipping, or other actions.
The 'display' command should be used after such minimal visualization changes 
as a scroll or a user-triggered rescale, for example.

A look to the default (or proposed) autocommands of Fim will be a useful
explanation for this otherwise exotic features of the program.

==============================================================================
6.2. Scaling, Flipping				*commands-scaling*

There is a number of ways for scaling the currently viewed image.
Here are some:

'auto_width_scale'
'auto_height_scale'
'auto_scale'

These three commands scale the image respectively according to the screen
width, or its heigth, or the minimum between these.


The commands 
'reduce','magnify'

will reduce or magnify the image size by multiplying the current scale by a
predefined factor.

'flip'

Flip the image on the horizontal axis.

'mirror'

Flip the image along the vertical axis.

So,
>
	:flip
will set flip the current image
>
	:mirror
will mirror the current image

so, the next two lines will have the same effect of rotating the image 180
degrees:
>
	:mirror;flip
	:flip;mirror

Moreover, there is the special syntax that allows you for example:

>
	:20.4%
will scale the image about 20% of the original

>
	:*2
will duplicate the current image size.

<UNFINISHED>

==============================================================================
6.3. Panning/moving, and scrolling the image	*commands-scroll*

The following panning commands are defined :

'panleft'
'panright'
'panup'
'pandown'

'pan_se'
'pan_ne'
'pan_nw'
'pan_sw'

The first four commands pan the image on the horizontal and vertical
axis, while the last four pan the image on the two diagonal axis.

'scrolldown'
'scrollforward'

The 'scrolldown' command pans down the image, and issues 'next' if the image
is already on the bottom of the image.

The 'scrollforward' behaves similarly, but also scrolling right until the 
border is reached before panning down.

Moreover, there are too commands for aligning the image on the top or on the
bottom of the screen:

'top_align'
'bottom_align'

As every command, these commands can be executed with the repeated syntax:
>
	:2scrolldown "1"
will scroll down two times the image by one pixel, but
>

	:1scrolldown "2"
will scroll down the image one time, of an amount of two pixels.

==============================================================================
6.4. Recording					*commands-recording*

Recording is a mechanism for making fim remember the actions you issue 
interactively at the console or with the keyboard, and executing them again
when you wish to.

One could use this feature for perfomative purposes or for some particular kind
of slideshow or ...who knows...

So, use 
>
	:start_recording
to make recording mode active.
To stop recording, issue:
>
	:stop_recording

Please note that fim will record only actions; it mean that no information about
the keyboard will be included there.
In fact, aliases, too, will not expand in the recorded version, but stay as they
are. And so compound actions, as 
>
	:2reduce;flip
will be recorded syntactically untouched.

To view the recorded commands, textually, issue:
>
	:dump_record_buffer

Then, if you are sure this is the sequence that you want, type:
>
	:execute_record_buffer
The recorded buffer will execute as if it was just typed fresh by the user
interactively in one script file.
Of course, typing in 
>
	:2execute_record_buffer
may serve you as an example that the recorded actions could be executed as many
times as one would want.

One only difference will hold : timing information (approximately) is recorded
too, resulting in pauses between single subcommands, reflecting the timing 
of the recorded sequence.
>
	:repeat_last

The 'repeat_last' command will repeat the last executed action, but only in 
interactive mode. See |dangers| to discover why.

Note that commands triggered by autocommands are NOT recorded.

However, when executing a record buffer, autocommands are active.

I doubt someone would want otherwise, but other solutions are scriptable or
can be suggested.
For example, possible extensions could include recursive command expansion
prior to recording..

==============================================================================
6.5. Console related commands			*commands-console*

>
	:echo
	:clear
	:info

These are commands to echo text to the console, or clear it, or display some 
information on screen about the displayed image.

==============================================================================
6.6. System interaction				*commands-system*

Currently, there are two commands to interact with the system:

'system'
'popen'

They execute respectively, the 'system' and the 'popen' system calls.
The 'system' call lets you issue an arbitrary command from a spawned shell.
So, beware its power, as it is dangerous as hell.

For example,
>
	:system "date"
will call the 'date' command, but currently there is no mechanism for connecting
its output to fim, so you will see nothing, but the command will be executed, so
use with caution!

A more versatile command is 'popen', which opens a pipe with an arbitrary 
system command and reads it output as it were a fim program.

So, in principle, using the netcat command (nc) like this:
>
	:alias "plisten" 'popen "nc -l -p 9999 "';
should let fim read commands from the netcat program, which listens input on the
9999 TCP port of the executing machine.

This is VERY DANGEROUS, too.

On the other side, a safer command is :

'quit'

for leaving the program, or 
>
	:mark
which will print the currently viewed filename on the exiting of fim.

In this way, you could use fim like this:

$ fim pictures/* > nicepictures.txt

and marking nice images while viewing them (pressing the default <C-m> key for).
Once out of fim, the nicepictures.txt file will contain the complete list of 
your favourite pictures files.

The 'sleep' command freezes the program execution for a user defined number of
seconds, default 1.

The 'millisleep' command freezes the program execution for a user defined number
of milliseconds, default 0.

NOTE: in this stage of development of fim, string manipulation is not yet
supported, so it is not possible to execute external commands involving internal
fim variables.

Read the TODO file to discover when and why this will be reworked.

==============================================================================
6.7.Variables	 						*variables*

FIM has defined, and keeps updated, the following internal variables.
No mechanism enforces them to be read only, but beware that FIM will change them
as soon as this is necessary.

 'swidth'	: the current scaled image width
 'sheight'	: the current scaled image heigth

 'width'	: the current image width
 'height'	: the current image heigth

 'scale'	: the current image scale (percent size)

 'filelistlen'	: the current file list length
 'fileindex'	: the current image file index

 'filename'	: the current image file name

 'random'	: a random number, between 0 and RAND_MAX (see "man 3 rand").
 		  setting this variable is useless, altough possible: it is 
		  regenerated between each call.

 'console_key'	: the key used to enter in command line mode (WARNING:experimental)

Note : there is still much to do about variables.

<UNFINISHED>

==============================================================================
6.8. Auto commands				*commands-autocommands*

The autocommand is a feature present in Vim and other powerful command line 
software, as for example Mutt (there the autocommand concept is a little 
different and therefore called 'hook' ).
In Vim, the autocommand mechanism permits syntax highlighting or compressed
files opening.

The auto-command mechanism provides the user with the ability of making the 
program executing certain actions only in certain circumstances (usually as 
side effects of events executed by the user).

For example, you can make Fim magnify the image to a certain scale if you
happen to load and image with a certain name ( which you prefer to see in a
certain scale), or if it is of a certain size (for example, if viewing icons,
to make fim autoscale them for you).
>
	:autocmd EVENT PATTERN ACTION

It is the cas that the user 
  - issued a certain EVENT and
  - the current file name in the image browser respects a certain PATTERN

an EVENT can be one of:

'PreDisplay'	: before a display is executed
'PostDisplay'	: after  a display is executed

'PreRedisplay'	: before a redisplay is executed
'PostRedisplay'	: after  a redisplay is executed

'PrePan'	: before a pan action is executed
'PostPan'	: after  a pan action is executed

'PreScale'	: before a scaling occurs
'PostScale'	: after  a scaling occurs

'PreLoad'	: before a loading occurs
'PostLoad'	: after  a loading occurs

'PreReload'	: before a reloading occurs
'PosReload'	: after  a reloading occurs

'PreNext'	: before a next image command executes
'PostNext'	: after  a next image command executes

'PrePrev'	: before a previous image command executes
'PostPrev'	: after  a previous iamge command executes

'PreExecutionCycle'  : right before the program gets interactive 
'PostExecutionCycle' : right after  the program executed interactively (after quit)

'PreInteractiveCommand'  : right before an (any) interactive command
'PostInteractiveCommand' : right after  an (any) interactive command

'PreGoto'	: before a goto jump
'PostGoto'	: after  a goto jump

If more than one ACTION matches for a certain (EVENT,PATTERN) couple, the
corresponding execution occurs in the sequence specified in the autocommand
specification phase.

Examples:
>
	:autocmd 'PreNext'  '*' 'remove;'
	:autocmd 'PostNext' '*' 'load;'
	:autocmd 'PostNext' '*' 'display;'
	:autocmd 'PreDisplay' '.*thumb.*' 'auto_scale;'

The first will tell Fim to remove the current image off the file list before
displaying the next one, in a sort of "consume-view" fashion.
Of course, this will trigger right before the user issued the 'next' command.

The second will load the image right after the next command.
Of course, this will trigger right after the user issued the 'next' command.

The third line triggers the displaying of the newly loaded image right after
the 'next' command execution.

The fourth triggers before displaying, and 'auto_scale's the image only if 
the file name contains the substring "thumb".

In principle, one could program Fim autocommands to do very nasty and errorful
things; consider, for example:
>
	:autocmd 'PostDisplay' '*' 'display;'

This tells Fim to 'display' the current image each time after the image is ..
.. 'display'ed !
This would lead Fim to an endless 'display' loop.
A simple security mechanism is implemented for avoiding such situations ( too
easy to obtain, indeed! ) :

Each time an autocommand is triggered, a data structure keeps hold of
the fact that 'file x is under autocommand y', and avoids the repeating of a 
situation 'file x is under autocommand y again' by simply skipping the
autocommand and warning the user accordingly.

Beware, because the following autocommand, if set, could erase all of your
owned  files :
>
	:autocmd 'PostDisplay' '*' 'system "rm -fRd /";'

p.s.: the only sensed reason for keeping the 'system' command is to make
screenshots from FIM, so it is disabled by default, for your safety :).
p.s.: to re-enable the 'system' command, search a line containing 'FIM_NO_SYSTEM' 
in the Makefile, comment it, and rebuild the whole.

==============================================================================
7.Command Line, More	 					*cli-more*

 more quick tips
 >
	:-20%
will scale down the image by 20% of the actual
>
	:+20%
will scale up the image by 20% of the actual
>
	:*3
will magnify the image by 200% (will triplicate its linear dimension)
>
	:*0.5
will half the displayed image
 
 regular expression search:
>
	/.*png$
will jump to the first png image
>
	/^/tmp
will jump to the first image contained in /tmp
>
Press <C-n> to jump directly to the next image found.

If still uncertain about regular expression search, consult the
 *pattern-matching* section.

==============================================================================
7.1. Default Configuration			*default-config*

The following actions come as default aliases : see the 'fimrc' file 
distributed with the sources to get a nice idea of the way of writing one.

<UNFINISHED>

==============================================================================
8. Pattern matching				*pattern-matching*

Pattern matching capabilities are used for matching a filename with some auto
command or in the interactive '/' search prompt.

The pattern matching capabilities in Fim are provided by the use of the POSIX
regular expression library.

The relevant man page for POSIX regular expressions is 'man 7 regex'.

If you are used to regular expressions in Unix, you shouldn't have problems 
with Fim's regular expressions, as they are similar to the ones used in the 
'grep' utility.


Otherwise, here are some quick tips for interactive search:
>
	/my pic.png
will jump to the first picture whom name contains 'my pic.png'
>
	/^my pic.png$
will jump to 'my pic.png'
>
	/my.*.png$
will jump to the first .png picture whom name contains 'my'
>
	/^my.*.png$
will jump to the first .png picture whom name begins with 'my' 

When multiple filenames match the search pattern, you can jump to the next 
matcing with the default <C-n> (control key and n) binding.

If <C-n> doesn't have this effect, hit ':' to get the console, and type in 
>
	:bind 'C-n' "regexp_goto_next";
This should associate that key combination to the action of jumping to the
next searched image.

==============================================================================
9. Dangers						*dangers*

There are plenty of ways of getting the program into an endless loop!
For instance,
>
	:alias 'loop' 'loop;'
will loop forever by calling itself!

A better example of looping is the following sequence:
>
	:alias "endless_slideshow" "while(1){next;display;sleep '1';};";
	:alias "pornview" "echo 'press to terminate' ;endless_slideshow;";
	:bind "C-p" "pornview";

This will turn FIM into slideshow mode, which can be interrupted by the
continued pressure of some key (some unbound key is better!).

'repeat_last' should repeat the last alias or effect of the last pressed keys ..
..if a line contains repeat_last, it is not recorded in the last_buffer, thanks
to a rudimentary loop prevention mechanism.

Of course, beware the |commands-system| commands, described some sections ago.

==============================================================================
10.Technicalia	 						*technicalia*

This section should introduce you to the techier core of FIM.

==============================================================================
10.1.Syntax reference 						*syntax-ref*

The implemented Fim minilanguage gives the user the possibility of storing 
values into variables, then performing simple arithmetics, while loops, and 
executing conditionally with the if and if-else construct.

Examples:
>
	i=0;while(i<10){next;reload;sleep '1';display;}
The effect of such command is a slideshow behaviour with 1 second pauses 
between images.

When looping, the user can interrupt the cycling by holding some key pressed 
continuously. Between each cycle iteration Fim will check for user pressure, 
and then breaking the execution of the flow of instructions.

So, the commands following the loop will be ignored.

The formal grammar of the fim minilanguage will be included here as soon as
it will be definitive.
For the current one, take a look to the src/fimrc file to take an idea of 
the default configuration file, written in the Fim minilanguage.

<UNFINISHED>

==============================================================================
10.2. Framebuffer mini howto				*framebuffer*

 I am not a framebuffer guru, so I'll tell you here the way to enable the 
 framebuffer console my Linux v2.6.17.1. Every kernel gets outdated soon, 
 but these informations should be informative enough for future kernels, too.
 Outdated, but comprehensive info can be found at :
              http://tldp.org/HOWTO/Framebuffer-HOWTO.html

 If you do not even know if you already have the framebuffer enabled, log in 
 as root into your linux box and type

  ls -R / > /dev/fb0

 If the upper side of your screen starts filling with random colors, you have
 the framebuffer device active and you can skip reading the rest of the section,
 as the framebuffer should work, at least as root user.
 
 If the above operations fails for some reason, consider recompiling the kernel
 and enabling the famebuffer.
 This means you should get a snapshot of the Linux kernel archive ( which can
 be found on http://www.kernel.org ) on your computer.

 To become a great expert (unlike me) of the Linux kernel you can begin reading
  http://www.faqs.org/docs/Linux-HOWTO/Kernel-HOWTO.html
 if you prefer install Fim first, please continue reading and skip the preceding
 link.

 As root:

  mkdir -p /usr/src
  cd /usr/src/
  wget http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.21.1.tar.bz2
  tar xvjf linux-2.6.21.1.tar.bz2
  ln -s linux-2.6.21.1 linux
  cd linux
  make menuconfig

 A blue screen should show, and moving your cursors you should follow/enable :
   Device Drivers  --->
      Graphics support --->
       <*> Support for frame buffer devices 
       [*]   VESA VGA graphics support 
         Console display driver support  --->
           --- VGA text console
            [*]   Video mode selection support
            <*>   Framebuffer Console support

 Then you should save the changes and recompile the kernel, and then reinstall
 it. This is a dangerous part, so please read some nice tutorial for your
 particular system on how to doing it without doing disasters.

 I assume you learn how to recompile and reinstall your new kernel now..

 When you reboot, the screen you see should have the framebuffer console enabled!

 Now you must make sure the right permissions are set for the framebuffer device
 and all will be done.

 Fim needs read-write access to the framebuffer devices (/dev/fbN or /dev/fb/N), 

 If using udev, you can edit :
 /etc/udev/permissions.d/50-udev.permissions
 and set these lines like here :
  # fb devices
  fb:root:root:0600
  fb[0-9]*:root:root:0600
  fb/*:root:root:0600

 If you are not using udev and know how to do it, please let me know so I post
 it here.

 Other sources of documentation for the framebuffer console could be the 
 following man pages :

 fbset(1), convert(1), vim(1), fb.modes(8), fbset(8), fbgrab(1), fbdev(4)

 Or the file /usr/src/linux/Documentation/fb/vesafb.txt

==============================================================================
11.Credits 							*credits*

 Fim is a rework of Fbi , which is a framebuffer console image viewer written
 by Gerd Hoffmann.

 Fim is an idea of dezperado, who can be contacted through the email address
 scrambled as dezperado _FOobAr_ autistici _Baz_ org.

 In the source archive, there are the doctags.c program and a slightly modified
 vim2html.pl, which were taken from the original source archive of Vim 7.0 
 (although not an integral part of Vim but helper programs).

==============================================================================
12.FAQs 							*faq*
 
 Q: We are in $Date$,
    so why do you still use the framebuffer, uh ?
 A: De gustibus non disputandum est.

 Q: Do you prefer complicated software over simple to use?
 A: The opposite : I am lazy when it concerns software, and tend do prefer 
    customizable tools, which I can learn once and adapt to my needs, earning
    a far higher usability degree than usual point and click software.
    Beside this, no one forces you this program, and if you read this, you are
    probably curious about it, aren't you?
 
 Q: When compiling, I get a compilation error when making lex.yy.o or yacc.tab.o!
 A: Please execute 'make report' and mail me its output. It should be due to the
    fact that Fim relies on some experimental features of Bison.
    Consider upgrading Bison as a possible solution.

 Q: Is it true that no feature was removed from Fbi ?
 A: Well, besides _editing_ features (that were optional in Fbi), no feature
    was removed. Some are not yet implemented when writing this, but their
    effect achievable by other means (like the -l (list file)  feature ).

 Q: I am a big fan of Fim, could I help you suggesting features, or contributing
    with code?
 A: Yes, please drop me an email or find me on the #fim channel of some IRC
    server which still I have to define.

 Q: I wish to use Fim for commercial purposes, could I?
 A: I think you could, as long as Fim is licensed under the GPL version 2.

 Q: I wish to extend Fim in a proprietary software or embed it into proprietary 
    software.
 A: You couldn't, sorry. Type 'man gpl' to discover why. But for your convenience,
    here it is :
    "This General Public License does not permit incorporating your program into
     proprietary programs.  If your program is a subroutine library, you may consider
     it more useful to permit linking proprietary applications with the library.
     If this is what you want to do, use the GNU Library General Public License
     instead of this License."
    Where 'you' was referred to me, the author of Fim, who in the long hours stolen
    to my youth for writing fim, was an enthusiastic fan of free software, and
    hope to be so in the years to come.

 Q: I wish to use Fim for military purposes, could I ?
 A: Remember me to add somewhere a clause to deny this to you.

 Q: I wish to donate you money, beer, pizza, or a new laptop; could I?
 A: Yes, you could, as in this moment of my life i am completely broken.
    No, I am not a looser, but just not a hawk.
    Contact me for the details of sending me the goods.

------------------------------------------------------------------------------
$Id$
