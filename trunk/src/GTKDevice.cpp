/*
 SDLDevice.h : GTK device Fim driver implementation file

 (c) 2023-2023 Michele Martone

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*/

// TODO: this is work in progress, don't use it.
// - need to cache more vars and eliminate redundancy of gdk_pixbuf_get_pixels()
// - move vars to (anyway singleton) class
// - in command line mode, clicking on menus may input command there
// - full screen mode to hide scrolldown menu
// - ...

#include <map>
#include "fim.h"

#ifdef FIM_WITH_LIBGTK

#include "DisplayDevice.h"
#include "GTKDevice.h"
#include <gtk/gtk.h>
#include <gdk/gdkkeysyms.h>
#include <gdk/gdkcairo.h>

#define FIM_GTK_DEBUG 1
#undef FIM_GTK_DEBUG

#define FIM_GTK_WITH_RENDERED_STATUSBAR 1 /* 1 to render, 0 to use statusbar_ */
#define FIM_GTK_WITH_MENUBAR 1
#define FIM_GTK_USE_NUL_SEPARATED_TOKENS 1

#ifdef FIM_GTK_DEBUG
#define FIM_GTK_DBG_COUT std::cout << "GTK:" << __FILE__ ":" << __LINE__ << ":" << __func__ << "() "
#define FIM_GTK_INPUT_DEBUG(C,MSG)  \
{ \
/* i miss sooo much printf() :'( */ \
FIM_GTK_DBG_COUT << (size_t)getmilliseconds() << " : "<<MSG<<" : "; \
std::cout.setf ( std::ios::hex, std::ios::basefield ); \
std::cout.setf ( std::ios::showbase ); \
std::cout << *(fim_key_t*)(C) <<"\n"; \
std::cout.unsetf ( std::ios::showbase ); \
std::cout.unsetf ( std::ios::hex ); \
}
#else /* FIM_GTK_DEBUG */
#define FIM_GTK_DBG_COUT if(0) std::cout 
#define FIM_GTK_INPUT_DEBUG(C,MSG) {}
#endif /* FIM_GTK_DEBUG */
#define FIM_WANT_POSITION_DISPLAYED FIM_WANT_MOUSE_PAN && 0

#define FIM_GTK_KEYSYM_TO_RL(X) ((X) | (1<<31)) // after FIM_SDL_KEYSYM_TO_RL
#define FIM_GTK_KEYSYM_TO_RL_CTRL(X) 1+((X)-'a') // after FIM_SDL_KEYSYM_TO_RL_CTRL

namespace fim
{
	extern fim_int fim_fmf_; /* FIXME */
	extern CommandConsole cc;
}

#define interactive_mode_ 0

	// here temporarily
	GtkWindow *window_{};
	GtkWidget *grid_{};
#if FIM_GTK_WITH_MENUBAR
	GtkWidget *menubar_{};
	std::map<std::string,GtkMenuItem*> menu_items_; // TODO: broken in GTK4: https://docs.gtk.org/gtk4/class.PopoverMenu.html
	std::map<std::string,std::set<GtkWidget*>> check_menu_items_; // TODO: may bring problems when actualizing
	std::map<GSList*,std::set<GtkWidget*>> group_widgets_; // TODO: may bring problems when actualizing
	std::map<std::string,GtkMenu*> menus_;

	GtkWidget *lmitMenu_{}; // TODO: FIXME: temporary
	std::vector<GtkWidget *> lms3Miv{4}; // TODO: FIXME: temporary
	int hist_n_{}; // TODO: FIXME: temporary
	std::map<std::string,std::string> seq_to_cmd_; // TODO: FIXME: temporary
	std::map<std::string,std::string> cmd_to_seq_; // TODO: FIXME: temporary
	std::map<std::string,void(*)(void)> cmd_funcs_; // TODO: FIXME: temporary
	std::map<std::string,std::string> vars_help_, vars_vals_; // TODO: FIXME: temporary
	std::map<std::string,std::string> help_; // TODO: FIXME: temporary
	std::string aliases_;
	std::string commands_;
	std::map<std::string,fim_key_t> sym_keys_; // TODO: FIXME: temporary
	GtkWidget *varsMenu_{}; /* a special menu with all commands, autogenerated via 'FimMenuVariables' */ // TODO: FIXME
	GtkWidget *aliaMenu_{}; /* a special menu with all commands, autogenerated via 'FimMenuAliases' */ // TODO: FIXME
	GtkWidget *keysMenu_{}; /* a special menu with all commands, autogenerated via 'FimMenuKeyBindings' */ // TODO: FIXME
#endif /* FIM_GTK_WITH_MENUBAR */
#if !FIM_GTK_WITH_RENDERED_STATUSBAR
	GtkWidget *statusbar_{};
#endif
	GtkWidget *drawingarea_{};
	guint context_id{};
	GtkWidget *cmdline_entry_{};
	GtkListStore *store_{};
	GtkTreeIter iter_{};
	GtkAccelGroup *accel_group_{};
	const std::string wtitle_ {"GTK-FIM -- no status yet"};
	bool control_pressed_{false};
	fim_key_t last_pressed_key_{0};
	GdkPixbuf * pixbuf{};
	fim_coo_t rowstride_{};
	fim_coo_t nw_{}, nh_{};
	int full_screen_{};
	int show_menubar_{1};

#pragma GCC push_options
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#pragma GCC diagnostic ignored "-Wunused-variable"

static void toggle_fullscreen(const bool full_screen)
{
	if (full_screen)
		gtk_window_fullscreen (GTK_WINDOW(window_));
	else
		gtk_window_unfullscreen (GTK_WINDOW(window_));
}


static gboolean cb_window_state_event(GtkWidget *window__unused, GdkEventKey* event)
{
	// minimize/maximize
	// TODO: need implementation
	return FALSE;
}

static fim_bpp_t _get_bpp(void) {
	// FIXME: is displaced
	return 8;
}

fim_bpp_t GTKDevice::get_bpp(void)const
{
	return _get_bpp();
}

void alloc_pixbuf(int nw, int nh)
{
	const auto alpha = FALSE; /* in gmacros.h */

	nw_ = nw;
	nh_ = nh;
	if(pixbuf)
		g_object_unref(pixbuf);
	pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, alpha, _get_bpp(), nw, nh);
	assert ( gdk_pixbuf_get_n_channels (pixbuf) == 3 );
	rowstride_ = gdk_pixbuf_get_rowstride (pixbuf);
	FIM_GTK_DBG_COUT << " nw:" << nw << " nh:" << nh << " pitch/3:" << rowstride_/GTKDevice::Bpp_ << "\n";
	memset (gdk_pixbuf_get_pixels(pixbuf), 0x0, rowstride_*nh); // black
}

static gboolean cb_window_event(GtkWidget *window__unused, GdkEventKey* event)
{
	FIM_GTK_DBG_COUT << " \n";

	// related to alloc_pixbuf

	cc.display_resize(gtk_widget_get_allocated_width((GtkWidget*)drawingarea_),gtk_widget_get_allocated_height((GtkWidget*)drawingarea_));
	return FALSE;
}

static gboolean cb_key_pressed(GtkWidget *window__unused, GdkEventKey* event)
{
	gboolean handled = FALSE;
	last_pressed_key_ = 0;

	if (event->keyval == GDK_KEY_Control_L)
	{
		if (event->type == GDK_KEY_RELEASE)
			control_pressed_ = true;
		if (event->type == GDK_KEY_PRESS)
			control_pressed_ = false;
	}

	if ((event->type == GDK_KEY_PRESS) /*&& (event->state & GDK_CONTROL_MASK)*/)
	{
		FIM_GTK_INPUT_DEBUG(&last_pressed_key_,"");
		std::string kst;

		if ( event->state & GDK_CONTROL_MASK )
			kst += "C-";
		last_pressed_key_ = event->keyval;

		if (last_pressed_key_ < 0x100) // isalpha & co don't require this
		if (isalpha(last_pressed_key_)) // if (last_pressed_key_ >= 'a') && (last_pressed_key_ <= 'z')
		if (isalnum(last_pressed_key_))
		if (isprint(last_pressed_key_))
		{
			if ( event->state & GDK_CONTROL_MASK )
				last_pressed_key_ = FIM_GTK_KEYSYM_TO_RL_CTRL(last_pressed_key_),
				handled = TRUE;
			if ( event->state & GDK_MOD1_MASK )
				last_pressed_key_ = FIM_GTK_KEYSYM_TO_RL(last_pressed_key_),
				handled = TRUE;
		}
		if (        last_pressed_key_ == GDK_KEY_Shift_L
			 || last_pressed_key_ == GDK_KEY_Shift_R
			 || last_pressed_key_ == GDK_KEY_Alt_L
			 || last_pressed_key_ == GDK_KEY_Alt_R
			 || last_pressed_key_ == GDK_KEY_Control_L
			 || last_pressed_key_ == GDK_KEY_Control_R
			)
			last_pressed_key_ = 0;
		if (last_pressed_key_ && handled == FALSE && last_pressed_key_ < 0x100)
			handled = TRUE;
		FIM_GTK_DBG_COUT << " handled=" << handled << "  last_pressed_key_=" << ((int)last_pressed_key_) << std::endl;
		// lots of garbage codes can still go in
	}
	return handled;
}

static gboolean cb_do_draw(GtkWidget *drawingarea, cairo_t * cr)
{
	// invoked by gtk_test_widget_wait_for_draw
	const fim_coo_t nw = gtk_widget_get_allocated_width(drawingarea),
			nh = gtk_widget_get_allocated_height(drawingarea);

	const bool nrsz = ( nw_ != nw || nh_ != nh );

	FIM_GTK_DBG_COUT << " " << nw_ << " " << nh_ << " " << (nrsz?'-':'=') <<  "-> " << nw << " " << nh << "  " << rowstride_/GTKDevice::Bpp_ << "\n";

	if ( !pixbuf || nrsz )
	{
		alloc_pixbuf(nw, nh);
		cc.display_resize(nw, nh);
	}

	gdk_cairo_set_source_pixbuf(cr, pixbuf, 0, 0);
	cairo_paint (cr);
	return TRUE;
}

static void keys_setup(fim::sym_keys_t&sym_keys)
{
	// populate GDK key code -> FIM key code
	std::map<fim_key_t,std::string> key_syms;

	if (!key_syms.size())
	{
		key_syms[GDK_KEY_Page_Up] = FIM_KBD_PAGEUP;
		key_syms[GDK_KEY_Page_Down] = FIM_KBD_PAGEDOWN;
		key_syms[GDK_KEY_Left] = FIM_KBD_LEFT;
		key_syms[GDK_KEY_Right] = FIM_KBD_RIGHT;
		key_syms[GDK_KEY_Up] = FIM_KBD_UP;
		key_syms[GDK_KEY_Down] = FIM_KBD_DOWN;
		key_syms[GDK_KEY_space] = FIM_KBD_SPACE;
		key_syms[GDK_KEY_End] = FIM_KBD_END;
		key_syms[GDK_KEY_Home] = FIM_KBD_HOME;
		key_syms[GDK_KEY_BackSpace] = FIM_KBD_BACKSPACE;
		key_syms[GDK_KEY_Tab] = FIM_KBD_TAB;
		key_syms[GDK_KEY_Return] = FIM_KBD_ENTER;
		key_syms[GDK_KEY_Pause] = FIM_KBD_PAUSE;
		key_syms[GDK_KEY_Insert] = FIM_KBD_INS;
		key_syms[GDK_KEY_Delete] = FIM_KBD_DEL;
		key_syms[GDK_KEY_Menu] = FIM_KBD_MENU;
		key_syms[GDK_KEY_Control_L] = "LeftControl";
		key_syms[GDK_KEY_Control_R] = "RightControl";
		key_syms[GDK_KEY_Escape] = "Esc";
		key_syms[GDK_KEY_colon] = FIM_KBD_COLON;
		key_syms[GDK_KEY_plus] = FIM_KBD_PLUS;
		key_syms[GDK_KEY_minus] = FIM_KBD_MINUS;
		// key_syms[GDK_KEY_function] = "Fn";
		// see /usr/include/gtk-3.0/gdk/gdkkeysyms.h
		// TODO: there is redundancy around here.
		for (fim_key_t k = '!'; k <= '~' ; ++ k )
			key_syms[k] = k;
		for (fim_key_t k = GDK_KEY_F1; k <= GDK_KEY_F12; ++ k )
			key_syms[k] = "F" + std::to_string(1+k-GDK_KEY_F1);
		for (const auto & ks: key_syms)
			sym_keys[ks.second] = ks.first;
		cc.key_syms_update();
	}
}

#if FIM_GTK_WITH_MENUBAR
const char * const menu_specs_ [] = {
"_File/_Open  open  C-o",
"_File/_Quit  quit  q",
"_File/_Next  next  n",
"_File/_Prev  prev  p",
//"_List/_Limit list  FimMenuLimit/", // FIXME: broken: causes lots of warnings when pressing 'a', therefore it's temporarily deactivated.
"_List/_Unlimit list  unlimit_list  u",
"_View/_Mirror  toggle_mirror  m",
"_View/_Flip  toggle_flip  f",
"_View/scale: _auto  scale_set_auto  a  scale: by _hand (manual)  scale_set_manual  m  scale: by _width  scale_set_auto_width  w",
"_View/_Verbose  toggle_verbose  v",
"_Window/_Fullscreen  toggle_fullscreen  F11",
"_Custom actions/scaling: _auto  scale_set_auto  a  scaling: manual  scale_set_manual  m  scaling: by _width  scale_set_auto_width  w",
"_Custom actions/_Toggle flipped flag  toggle_flip  f",
"_Custom actions/_Submenu/_Frobnicate  unmapped_cmd  /",
"_Custom actions/_Submenu/_Defrobnicate  unmapped_cmd  u",
"_Custom actions/_Submenu/_Do-frobnicate  unmapped_cmd *",
"_Custom actions/_Submenu/_Fribnikate  frobnicate  unmapped_cmd *",
"_Custom actions/_Add menu...  menu_dialog",
"_Custom actions/_Toggle full screen view  toggle_fullscreen",
"_All actions/_Commands  FimMenuCommands/",
"_All actions/_Aliases  FimMenuAliases/",
"_All actions/_Key Bindings  FimMenuKeyBindings/",
"_All actions/_Variables  FimMenuVariables/",
"_Help/_Commands  FimMenuCommandsHelp/",
"_Help/_Aliases  FimMenuAliasesHelp/",
"_Help/_Key Bindings  FimMenuKeyBindingsHelp/",
"_Help/_Variables  FimMenuVariablesHelp/",
"_Help/_Man FIM  man_fim",
"_Help/_Man fimrc  man_fimrc",
};

#define verbose_ 0 /* FIXME */

typedef std::pair<fim_key_t,GdkModifierType> km_t;

static km_t str_to_km(const char *s)
{
	const GdkModifierType no_kmod {( GdkModifierType )0}; /* no constant for 0 otherwise in Gdk3 */
	GdkModifierType mmask {no_kmod};

	if ( strlen(s) >= 3 && s[0] == 'C' && s[1] == '-' )
		mmask = GDK_CONTROL_MASK,
		s += 2;

	if ( sym_keys_.find(s) != sym_keys_.end() )
		return km_t {sym_keys_[s],mmask};
	else
		return km_t {'\0',mmask};
}

static const char *sym_strstr(const char *haystack, const char *needle)
{
	const int nl = strlen(needle);
	const char * s = strstr(haystack, needle);

	if ( s && ( !s[nl] || !isalpha(s[nl]) ) )
		return s;
	else
		return NULL;
}

std::string do_get_item_help(const char* item)
{
	const auto ih = cc.get_help(item, 'l');
	return ih;
}

#if FIM_GTK_USE_NUL_SEPARATED_TOKENS
#define xtrcttkn(X) std::string(X)
#else /* FIM_GTK_USE_NUL_SEPARATED_TOKENS */
static std::string xtrcttkn(const char* cmd)
{
	const auto sc = strchr(cmd, ' ');
	std::string cmds;
	cmds = std::string(cmd, sc ? sc : cmd+strlen(cmd));
	return cmds;
}
#endif /* FIM_GTK_USE_NUL_SEPARATED_TOKENS */

void do_print_item_help(GtkWidget *, const char* item)
{
	cc.execute("echo", { do_get_item_help(xtrcttkn(item).c_str()) } ); // TODO: FIXME: this goes better to status, as long as in interactive mode
}

void cb_cc_exec(GtkWidget *, const char* cmd)
{
	cc.execute(xtrcttkn(cmd).c_str(), {});
}

void do_print_var_val(GtkWidget *, const char* var)
{
	const auto vv = cc.getStringVariable(var) + "\n";
	cc.execute("echo", { std::string(var) + " is: " + std::string(vv)} ); // TODO: FIXME: this goes better to status, as long as in interactive mode
}

void do_rebuild_help_aliases_menu(GtkWidget *aliaMi, const bool help_or_cmd)
{
	if(aliaMi) // workaround around warnings in gtk_menu_item_set_submenu
		gtk_menu_item_set_submenu(GTK_MENU_ITEM(aliaMi), NULL);
	aliaMenu_ = gtk_menu_new();
	g_object_ref_sink(aliaMenu_);
	if(aliaMi && aliaMenu_) // workaround around warnings in gtk_menu_item_set_submenu
		gtk_menu_item_set_submenu(GTK_MENU_ITEM(aliaMi), aliaMenu_);

	for (auto a0 = 0UL, a1 = aliases_.find(' '); a0 < a1 && a1!=std::string::npos ; a0 = a1+1, a1 = aliases_.find(' ',a1+1) )
	{
		const auto alias = aliases_.substr(a0,a1-a0);
#if FIM_GTK_USE_NUL_SEPARATED_TOKENS
		aliases_[a1] = FIM_SYM_CHAR_NUL;
#endif /* FIM_GTK_USE_NUL_SEPARATED_TOKENS */
		void * ap = (void*) (aliases_.c_str()+a0);
		GtkWidget * const aliMi = gtk_menu_item_new_with_label(alias.c_str());
		gtk_widget_set_tooltip_text(aliMi, alias.c_str() );
		{
			if ( help_or_cmd )
				g_signal_connect( G_OBJECT(aliMi), "activate", G_CALLBACK( do_print_item_help ), ap ); // TODO; need specific help mechanism..
			else
				g_signal_connect( G_OBJECT(aliMi), "activate", G_CALLBACK( cb_cc_exec ), ap );
		}
		gtk_menu_shell_append(GTK_MENU_SHELL(aliaMenu_), aliMi);
		gtk_widget_show(aliMi);
	}
	gtk_widget_show(aliaMenu_);
}

void do_rebuild_help_variables_menu(GtkWidget *varsMi, const bool help_or_cmd)
{
	if(varsMi)
		gtk_menu_item_set_submenu(GTK_MENU_ITEM(varsMi), NULL);
	varsMenu_ = gtk_menu_new();
	g_object_ref_sink(varsMenu_);
	if(varsMi)
		gtk_menu_item_set_submenu(GTK_MENU_ITEM(varsMi), varsMenu_);

	for (const auto & var : vars_help_)
	{
		if(verbose_) std::cout << "VAR: " << var.first << std::endl;
		GtkWidget * const varMi = gtk_menu_item_new_with_label(var.first.c_str());
		if ( vars_vals_.find(var.first) == vars_vals_.end() )
			return;
		if (help_or_cmd)
			gtk_widget_set_tooltip_text(varMi, (var.second + " ... and click to see help...").c_str() ),
			g_signal_connect( G_OBJECT(varMi), "activate", G_CALLBACK( do_print_item_help ), (void*) var.first.c_str() );
		else
			gtk_widget_set_tooltip_text(varMi, (var.second + " ... and click to see value ...").c_str() ),
			g_signal_connect( G_OBJECT(varMi), "activate", G_CALLBACK( do_print_var_val ), (void*) var.first.c_str() );
		gtk_menu_shell_append(GTK_MENU_SHELL(varsMenu_), varMi);
		gtk_widget_show(varMi);
	}
	gtk_widget_show(varsMenu_);
}

void do_rebuild_help_commands_menu(GtkWidget *cmdsMi, const bool help_or_press)
{
	if(cmdsMi) // workaround around warnings in gtk_menu_item_set_submenu
		gtk_menu_item_set_submenu(GTK_MENU_ITEM(cmdsMi), NULL);
	GtkWidget *cmdsMenu{}; /* special menu with all commands, autogenerated via 'FimMenuCommandsHelp' */
	cmdsMenu = gtk_menu_new();
	g_object_ref_sink(cmdsMenu);
	if(cmdsMi && cmdsMenu) // workaround around warnings in gtk_menu_item_set_submenu
		gtk_menu_item_set_submenu(GTK_MENU_ITEM(cmdsMi), cmdsMenu);


	for (auto c0 = 0UL, c1 = commands_.find(' '); c0 < c1 && c1!=std::string::npos ; c0 = c1+1, c1 = commands_.find(' ',c1+1) )
	{
		const auto cmd = commands_.substr(c0,c1-c0);
#if FIM_GTK_USE_NUL_SEPARATED_TOKENS
		commands_[c1] = FIM_SYM_CHAR_NUL;
#endif /* FIM_GTK_USE_NUL_SEPARATED_TOKENS */
		void * cp = (void*) (commands_.c_str()+c0);
		// TODO: what about cmd_to_seq_?
		const auto & csi = cmd_to_seq_.find(cmd);
		GtkWidget * const cmdMi = gtk_menu_item_new_with_label(cmd.c_str());
		gtk_widget_set_tooltip_text(cmdMi, (cmd + ": " + do_get_item_help(cmd.c_str())).c_str() ); // help msg

		if ( csi != cmd_to_seq_.end() )
		{
			const auto & cs = *csi;
			const auto & sc = *seq_to_cmd_.find(cs.second);
			//const std::string & seq = sc.first;
			const km_t km = str_to_km(sc.first.c_str());

			if ( km.first )
			{
				const fim_key_t key = km.first;
				const GdkModifierType mmask = km.second;
				gtk_widget_add_accelerator(cmdMi, "activate", accel_group_, key, mmask, GTK_ACCEL_VISIBLE);
			}
		}

		if ( true )
		//if ( cmd_funcs_.find(cmd) != cmd_funcs_.end() )
		{
			if ( help_or_press )
				g_signal_connect(G_OBJECT(cmdMi), "activate", G_CALLBACK( do_print_item_help ), cp );
			else
				g_signal_connect(G_OBJECT(cmdMi), "activate", G_CALLBACK( cb_cc_exec ), cp);
		}
		else
			if(verbose_) std::cout << "Warning: no command found for " << cmd << std::endl;

		gtk_menu_shell_append(GTK_MENU_SHELL(cmdsMenu), cmdMi);
		gtk_widget_show(cmdMi);
	}
	gtk_widget_show(cmdsMenu);
}

void do_rebuild_help_bindings_menu(GtkWidget *keysMi, const bool help_or_press)
{
	if(keysMi) // workaround around warnings in gtk_menu_item_set_submenu
		gtk_menu_item_set_submenu(GTK_MENU_ITEM(keysMi), NULL);
	keysMenu_ = gtk_menu_new();
	g_object_ref_sink(keysMenu_);
	if(keysMi && keysMenu_) // workaround around warnings in gtk_menu_item_set_submenu
		gtk_menu_item_set_submenu(GTK_MENU_ITEM(keysMi), keysMenu_);

	for (const auto & sc : seq_to_cmd_)
	{
		GtkWidget * const keyMi = gtk_menu_item_new_with_label(sc.second.c_str());
		gtk_widget_set_tooltip_text(keyMi, (sc.second + " ...").c_str() );
		const km_t km = str_to_km(sc.first.c_str());

		if ( km.first )
		{
			const fim_key_t key = km.first;
			const GdkModifierType mmask = km.second;

			gtk_widget_add_accelerator(keyMi, "activate", accel_group_, key, mmask, GTK_ACCEL_VISIBLE);
		}

		if ( cmd_funcs_.find(sc.second) != cmd_funcs_.end() )
		{
			if ( help_or_press )
				g_signal_connect(G_OBJECT(keyMi), "activate", G_CALLBACK( do_print_item_help ), (void*) sc.second.c_str() );
			else
				g_signal_connect(G_OBJECT(keyMi), "activate", G_CALLBACK( cmd_funcs_[sc.second] ), NULL);
		}

		gtk_menu_shell_append(GTK_MENU_SHELL(keysMenu_), keyMi);
		gtk_widget_show(keyMi);
	}
	gtk_widget_show(keysMenu_);
} /* do_rebuild_help_bindings_menu */

void cb_do_limit(GtkWidget * ,GtkWidget * w)
{
	const int idx = w-(lms3Miv[0]);
	if(verbose_) std::cout << "limit using index " << idx + 1 << "\n";
}

void rebuild_limit_menu(GtkWidget*lmitMi)
{
	// FIXME: TODO: replace this stub
	const size_t N = lms3Miv.size();
	// Note: not clear how to free memory of lmitMenu_.
	// Considered gtk_container_remove, gtk_menu_shell_deactivate, gtk_menu_detach, GTK_WIDGET_DESTROY, g_object_unref, without much success.
	// Reason is warnings and leak persists.
	// The current solution seem to leak very modestly.
	gtk_menu_item_set_submenu(GTK_MENU_ITEM(lmitMi), NULL);

	lmitMenu_ = gtk_menu_new();
	g_object_ref_sink(lmitMenu_);
	gtk_menu_item_set_submenu(GTK_MENU_ITEM(lmitMi), lmitMenu_);

	// const size_t M = 3000; // fast forward to exacerbate any memory leak
	const size_t M = 1;
	for (size_t j = 0; j < M; ++j)
	for (size_t i = 0; i < N; ++i)
	{
		if (lms3Miv[i])
		{
			//GTK_WIDGET_DESTROY(GTK_WIDGET(lms3Miv[i])); // seemingly bad
			//g_free:(GTK_WIDGET(lms3Miv[i])); // ?
			gtk_widget_remove_accelerator(lms3Miv[i], accel_group_, GDK_KEY_1 + i, GDK_CONTROL_MASK);
			//gtk_container_remove(GTK_CONTAINER(lmitMenu_), lms3Miv[i]);

			// https://bugzilla.redhat.com/show_bug.cgi?id=1970254 suggests to use the two of:
			g_object_unref (lms3Miv[i]);
			/// g_object_unref(lms3Miv[i]); //  g_object_unref: assertion 'G_IS_OBJECT (object)' failed // changing order seems no solution
			// ...but leak still there.
		}
		std::string lbl = "Limit Sample " + std::to_string(hist_n_) +
			" (_" + std::to_string(i+1) + ")"
			;
		hist_n_++;
		lms3Miv[i] = gtk_menu_item_new_with_mnemonic(lbl.c_str());
		gtk_menu_shell_append(GTK_MENU_SHELL(lmitMenu_), lms3Miv[i]);
		g_signal_connect(G_OBJECT(lms3Miv[i]), "activate", G_CALLBACK(cb_do_limit), (lms3Miv[0]+i));
		gtk_widget_set_tooltip_text(lms3Miv[i], "limit file list to ...");
		gtk_widget_show(lms3Miv[i]);
		gtk_widget_add_accelerator(lms3Miv[i], "activate", accel_group_, GDK_KEY_1 + i, GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
	}
	gtk_widget_show(lmitMenu_);
}

void cb_on_open_response (GtkDialog *dialog, int response)
{
	if (response == GTK_RESPONSE_ACCEPT) {
		std::string msg ("opening ");
		char * const fn = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
		msg += fn;
		g_free (fn);
#if FIM_GTK_WITH_RENDERED_STATUSBAR
// FIXME
#else
		gtk_statusbar_push(GTK_STATUSBAR(statusbar_), context_id, msg.c_str());
#endif
	}
	gtk_widget_destroy (GTK_WIDGET(dialog));
	dialog = NULL;
	//GTK_WIDGET_DESTROY(GTK_WIDGET(dialog));
}

static gboolean cb_open_file( GtkMenuItem*)
{
	GtkWidget *dialog = gtk_file_chooser_dialog_new("Open..", GTK_WINDOW(window_), GTK_FILE_CHOOSER_ACTION_OPEN, "apri", GTK_RESPONSE_ACCEPT, "no", GTK_RESPONSE_CANCEL, NULL);
	gtk_widget_show(dialog);
	g_signal_connect (dialog, "response", G_CALLBACK (cb_on_open_response), NULL);
	return FALSE;
}

static bool add_to_menubar(const char *s)
{
	// add one menu item to the menu
	// FIXME: return false on error and react consequently
	const char *st = "  "; // separator token
	const char *e;
	const char *b = s;
	std::string add;
	std::string top;
	std::string lbl;

	if(verbose_) std::cout << s << std::endl;

	int tc = 0; // token count
	const char * p = b;
	GSList *menuGr {};
	std::set<GtkWidget*> radioset {};

	while ( ( p = strstr(p + 2, st) ) )
		++tc;

	while ( ( e = strchr(b, '/') ) && e[-1] != ' ' )
	{
		const char * l = strstr(b, st);
		char new_submenu = 'n';

		if ( l && l + 2 < e )
			lbl = std::string(b,0,l-b);
		else
			lbl = std::string(b,0,e-b);

		top = add;
		add += '/';
		if(verbose_) std::cout << "LBL: " << add << " : " << lbl << "\n";
		add += lbl;

		if ( menus_.find(add) == menus_.end() )
			new_submenu = 'y';

		if ( l && l + 2 < e && l + 2 == strstr( l + 2, "FimMenu" ) )
		{
			new_submenu = 's'; // special
			l += 2;
			if(verbose_) std::cout << "SPECIAL\n";
		}

		if(verbose_) std::cout << "SMN " << add << " : " << ' ' << " : " << new_submenu << std::endl;
		if ( new_submenu != 'n' )
			menu_items_[add] = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic(lbl.c_str());
		if ( new_submenu == 's' )
		{
			// TODO: versions of these with extras or without
			if ( l == sym_strstr( l, "FimMenuAliases" ) )
				do_rebuild_help_aliases_menu((GtkWidget*)menu_items_[add],false);
			if ( l == strstr( l, "FimMenuAliasesHelp" ) )
				do_rebuild_help_aliases_menu((GtkWidget*)menu_items_[add],true);
			if ( l == sym_strstr( l, "FimMenuKeyBindings" ) )
				do_rebuild_help_bindings_menu((GtkWidget*)menu_items_[add],false);
			if ( l == strstr( l, "FimMenuKeyBindingsHelp" ) )
				do_rebuild_help_bindings_menu((GtkWidget*)menu_items_[add],true);
			if ( l == sym_strstr( l, "FimMenuCommands" ) )
				do_rebuild_help_commands_menu((GtkWidget*)menu_items_[add],false);
			if ( l == strstr( l, "FimMenuCommandsHelp" ) )
				do_rebuild_help_commands_menu((GtkWidget*)menu_items_[add],true);
			if ( l == sym_strstr( l, "FimMenuVariables" ) )
				do_rebuild_help_variables_menu((GtkWidget*)menu_items_[add],false);
			if ( l == strstr( l, "FimMenuVariablesHelp" ) )
				do_rebuild_help_variables_menu((GtkWidget*)menu_items_[add],true);
			if ( l == strstr( l, "FimMenuLimit" ) )
				rebuild_limit_menu((GtkWidget*)menu_items_[add]);
		}
		if ( new_submenu != 'n' )
			menus_[add] = (GtkMenu*) gtk_menu_new();
		if ( new_submenu == 'y' )
			gtk_menu_item_set_submenu(GTK_MENU_ITEM(menu_items_[add]), (GtkWidget*)menus_[add]);
		if ( new_submenu != 'n' )
		{
			if ( b == s )
				gtk_menu_shell_append(GTK_MENU_SHELL(menubar_), (GtkWidget*)menu_items_[add]);
			else
				gtk_menu_shell_append(GTK_MENU_SHELL(menus_[top]), (GtkWidget*)menu_items_[add]);
		}
		b = e + 1;
	}

	top = add;
repeat:
	if ( ( e = strstr(b, st) ) )
	{
		// b = e + 2;
		if(verbose_) std::cout << "e: " << e << "  " << "\n";
		lbl = std::string(b,0,e-b);
		add = top;
		add += '/';
		if(verbose_) std::cout << "ADD: " << add << "\n";
		if(verbose_) std::cout << "LBL: " << lbl << "\n";
		add += lbl;
		if ( ! *e )
		{
			// TODO: eliminate this branch
			std:: cout << "TERMINAL" << b << "\n";
			if ( menu_items_.find(add) == menu_items_.end() )
				menu_items_[add] = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic(lbl.c_str());
			gtk_menu_shell_append(GTK_MENU_SHELL(menus_[top]), (GtkWidget*)menu_items_[add]);
		}
		b = e + 2;
	}

	if ( ( e = strstr(b, st) ) || ( e = b + strlen(b) ) )
	{
		const auto cmd = std::string(b,0,e-b);

		if ( menu_items_.find(add) == menu_items_.end() )
		{
			if(verbose_) std:: cout << "COMMAND " << e-b << ":" << cmd << "\n";
			if ( b == strstr(b, "toggle") )
				menu_items_[add] = (GtkMenuItem*) gtk_check_menu_item_new_with_mnemonic(lbl.c_str()),
				check_menu_items_[cmd].insert((GtkWidget*) menu_items_[add]),
				gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menu_items_[add]), FALSE);
			else
			{
				if (tc > 2)
				{
					if(verbose_) std:: cout << "RADIO " << add << "\n";
					menu_items_[add] = (GtkMenuItem*) gtk_radio_menu_item_new_with_mnemonic(menuGr, lbl.c_str()),
					check_menu_items_[cmd].insert((GtkWidget*) menu_items_[add]),
					menuGr = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(menu_items_[add])),
					radioset.insert((GtkWidget*) menu_items_[add]);
				}
				else
					menu_items_[add] = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic(lbl.c_str());
			}
		}

		if (! gtk_widget_get_parent((GtkWidget*)menu_items_[add]))
			gtk_menu_shell_append(GTK_MENU_SHELL(menus_[top]), (GtkWidget*)menu_items_[add]);

		if(verbose_) std::cout << "CMD: " << top << " + " << cmd << "\n";
		if (cmd.size())
		{
#if 0
			if ( b == strstr(b, "toggle") )
				g_signal_connect(G_OBJECT(menu_items_[add]), "toggled", G_CALLBACK(cmd_funcs_[cmd]), NULL);
			else
				g_signal_connect(G_OBJECT(menu_items_[add]), "activate", G_CALLBACK(cmd_funcs_[cmd]), NULL);
#endif
			//if ( cmd_funcs_.find(cmd) != cmd_funcs_.end() )
			if ( true )
			{
				g_signal_connect(G_OBJECT(menu_items_[add]), "activate", G_CALLBACK(cmd_funcs_["man_fimrc"]), NULL);
				gtk_widget_set_tooltip_text((GtkWidget*)menu_items_[add], cmd.c_str());
			}
			else
			{
				if(verbose_) std::cout << "Warning: no command found for " << cmd << " so cannot give action to menu" << std::endl;
			}
		}

		if ( ! *e )
			;
		else
		{
			const char * ss = strstr(b = e + 2, st);
			const std::string sym = ss ? std::string(b, 0, ss - b) : std::string(b);
			const km_t km = str_to_km(sym.c_str());
			if( km.first )
				gtk_widget_add_accelerator( (GtkWidget*)menu_items_[add], "activate", accel_group_, km.first, km.second, GTK_ACCEL_VISIBLE);
			e = strstr(b, st); // e points after symbol
		}
	}

	if ( e && /* (tc + 2) / 3 > 1 && */ *e ) // && ! menuGr )
	{
		assert ( strstr(b, st) );
		b = e + 2;
		if(verbose_) std::cout << "AGAIN: " << b << " " << "\n";
		e = strstr(b, st);
		if(verbose_) std::cout << "GROUPING: " << s << "\n";
		if (e)
			goto repeat;
	}

	if (menuGr)
		group_widgets_[menuGr] = radioset;
	return true;
} /* add_to_menubar */

static gboolean cb_menu_dialog(GtkMenuItem*)
{
	GtkWidget *entry;
	GtkEntryCompletion *completion;
	GtkListStore *store;
	completion = gtk_entry_completion_new();
	GtkWidget *dialog = gtk_dialog_new_with_buttons("Add menu dialog", GTK_WINDOW(window_),
		GTK_DIALOG_MODAL,
		//GTK_DIALOG_DESTROY_WITH_PARENT,
		"Ok", GTK_RESPONSE_OK,
		NULL );
	entry = gtk_entry_new();
	gtk_widget_set_hexpand(GTK_WIDGET(entry), TRUE);
	gtk_widget_set_halign(GTK_WIDGET(entry), GTK_ALIGN_START);
	gtk_widget_set_margin_top(GTK_WIDGET(entry), 0);
	gtk_widget_set_margin_bottom(GTK_WIDGET(entry), 0);
	gtk_entry_get_activates_default(GTK_ENTRY(entry));
	gtk_entry_set_has_frame(GTK_ENTRY(entry), FALSE);
	gtk_entry_set_width_chars(GTK_ENTRY(entry), 80);
	store = gtk_list_store_new (1, G_TYPE_STRING);
	for (size_t i = 0; i < sizeof(menu_specs_)/sizeof(menu_specs_[0]) ; i++)
	{
		gtk_list_store_append (store, &iter_);
		gtk_list_store_set (store, &iter_, 0, menu_specs_[i], -1);
	}
	gtk_entry_set_completion (GTK_ENTRY (entry), completion);
	gtk_entry_completion_set_model (completion, GTK_TREE_MODEL (store));
	gtk_entry_completion_set_text_column (completion, 0);
	gtk_entry_completion_set_minimum_key_length(completion, 0);
	gtk_dialog_add_action_widget (GTK_DIALOG(dialog), entry, 0);
	gtk_dialog_set_default_response(GTK_DIALOG(dialog), GTK_RESPONSE_OK);
	gtk_entry_set_text(GTK_ENTRY(entry), menu_specs_[0]);
	gtk_widget_show_all(entry);
	gtk_widget_show_all(dialog);
	const auto result = gtk_dialog_run(GTK_DIALOG(dialog));
	if (result != GTK_RESPONSE_OK && result != 0)
		std::cout << "Warning: wrong dialog termination : " << result << "\n";
	else
	{
		const std::string rspns = gtk_entry_get_text(GTK_ENTRY(entry));
		std::cout << "Using menu spec : " << rspns << " after getting code " << result << "\n";
		if (rspns.size())
			add_to_menubar(rspns.c_str()),
			gtk_widget_show_all(menubar_);
	}
	gtk_widget_destroy (dialog);
	//GTK_WIDGET_DESTROY(GTK_WIDGET(dialog));
	return TRUE;
}

static void refresh_commands(void) {
	cmd_funcs_["another_unmapped_cmd"] = [](){ std::cout << "another unmapped cmd\n"; };
	vars_help_["_var"] = "a random variable";
	vars_vals_["_var"] = "val";
	seq_to_cmd_[" "] = "repeat"; // FIXME: non-existing command
	cmd_to_seq_["repeat"] = " ";
}

static void do_init_cmd_funcs(void)
{
	// bind actual functionality to commands
	vars_vals_["_filelistlen"] = "whatever";
	vars_help_["_filelistlen"] = "whatever";
	vars_vals_["_all_file_loaders"] = "whatever";
	vars_help_["_all_file_loaders"] = "whatever";
	cmd_funcs_["open"] = [](){ cb_open_file(NULL); };
	cmd_funcs_["menu_dialog"] = [](){ cb_menu_dialog(NULL); };
	cmd_funcs_["rebuild_limit_menu"] = [](){ };
	//cmd_funcs_["refresh_commands"] = [](){ refresh_commands(); do_rebuild_help_variables_menu(varsMi_,true);do_rebuild_help_variables_menu(varsMi_,false); }; // only for testing add_new_alias_and_variable
	cmd_funcs_["refresh_commands"] = [](){
		refresh_commands(); 
		// do_rebuild_help_menus();
		std::cout << "rebuilt help menus"; 
	};
	cmd_funcs_["toggle_flip"] = [](){ };
	cmd_funcs_["toggle_mirror"] = [](){  };
	cmd_funcs_["toggle_verbose"] = [](){ };
	cmd_funcs_["toggle_statusbar"] = [](){ };
	cmd_funcs_["toggle_menubar"] = [](){ };
	cmd_funcs_["toggle_fullscreen"] = [](){ };
	cmd_funcs_["magnify"] = [](){ };
	cmd_funcs_["man_fim"] = [](){ system("konsole -e man fim"); };
	cmd_funcs_["man_fimrc"] = [](){ system("konsole -e man fimrc"); };
	cmd_funcs_["scale_set_manual"] = [](){ };
	cmd_funcs_["scale_set_auto_width"] = [](){ }; // __radio__autowidth__2
	cmd_funcs_["unlimit_list"] = [](){ std::cout << "unlimit list\n"; };
	cmd_funcs_["add_new_alias_and_variable"] = [](){ 
		std::cout << "adding custom alias and variable\n";
		vars_help_["new_variable"]=vars_vals_["new_variable"]="new_variable_value";
		vars_help_["wtitle"]=vars_vals_["wtitle"]="GTK FIM barebone new title";
		help_["new_variable"]="new_variable help is: ...";
		help_["new_alias"]="new_alias help is: ...";
		// do_rebuild_help_menus(); // for demo purposes
		// TODO: reinit autocompletion
	};
}

void do_rebuild_help_menus(void)
{
	if (menubar_)
		gtk_container_remove (GTK_CONTAINER(grid_), menubar_);
	menu_items_ = {};
	check_menu_items_ = {};
	group_widgets_ = {};
	menus_ = {};

	menubar_ = gtk_menu_bar_new();
	gtk_widget_set_vexpand(GTK_WIDGET(menubar_), FALSE);
	gtk_widget_set_hexpand(GTK_WIDGET(menubar_), FALSE);
	gtk_widget_set_margin_top(GTK_WIDGET(menubar_), 0);
	gtk_widget_set_margin_bottom(GTK_WIDGET(menubar_), 0);
	gtk_grid_attach_next_to (GTK_GRID(grid_), GTK_WIDGET(menubar_), GTK_WIDGET(drawingarea_), GTK_POS_TOP, 1, 1);

	aliases_ = cc.get_aliases_list(); // note: this invalidates widgets
	commands_ = cc.get_commands_list(); // note: this invalidates widgets

	// new stuff
	for (const auto menu_spec: menu_specs_)
		add_to_menubar(menu_spec);
	//for (size_t i = 0; i < sizeof(menu_specs_)/sizeof(menu_specs_[0]) ; i++)
		//add_to_menubar(menu_specs_[i]);
//	gtk_widget_show_all (GTK_WIDGET(window_));
//	gtk_widget_hide (cmdline_entry_);
} /* do_rebuild_help_menus */
#endif /* FIM_GTK_WITH_MENUBAR */

fim_err_t GTKDevice::initialize(fim::sym_keys_t&sym_keys)
{
	do_init_cmd_funcs();
	gtk_init(NULL, NULL);
	window_ = GTK_WINDOW(gtk_window_new(GTK_WINDOW_TOPLEVEL));
	gtk_window_set_position(GTK_WINDOW(window_), GTK_WIN_POS_CENTER);
	gtk_window_set_default_size(GTK_WINDOW(window_), FIM_DEFAULT_WINDOW_WIDTH, FIM_DEFAULT_WINDOW_HEIGHT);
	set_wm_caption(wtitle_.c_str());
	gtk_widget_add_events(GTK_WIDGET(window_), GDK_BUTTON_PRESS_MASK);
	grid_ = gtk_grid_new();
#if !FIM_GTK_WITH_RENDERED_STATUSBAR
	statusbar_ = gtk_statusbar_new();
	gtk_widget_set_vexpand(GTK_WIDGET(statusbar_), FALSE);
	gtk_widget_set_hexpand(GTK_WIDGET(statusbar_), TRUE);
	gtk_widget_set_valign(GTK_WIDGET(statusbar_), GTK_ALIGN_END);
	gtk_widget_set_margin_top(GTK_WIDGET(statusbar_), 0);
	gtk_widget_set_margin_bottom(GTK_WIDGET(statusbar_), 0);
	gtk_widget_set_margin_start(GTK_WIDGET(statusbar_), 0);
	gtk_widget_set_margin_end(GTK_WIDGET(statusbar_), 0);
#endif
	drawingarea_ = gtk_drawing_area_new();
	gtk_widget_set_vexpand(GTK_WIDGET(drawingarea_), TRUE);
	gtk_widget_set_hexpand(GTK_WIDGET(drawingarea_), TRUE);
#if !FIM_GTK_WITH_RENDERED_STATUSBAR
	context_id = gtk_statusbar_get_context_id(GTK_STATUSBAR(statusbar_), "context");
	gtk_statusbar_push (GTK_STATUSBAR(statusbar_), context_id, "Waiting for you to do something...");
	gtk_grid_attach(GTK_GRID(grid_), GTK_WIDGET(drawingarea_), 0, 1, 1, 1);
	gtk_grid_attach_next_to(GTK_GRID(grid_), GTK_WIDGET(statusbar_), GTK_WIDGET(drawingarea_), GTK_POS_BOTTOM, 1, 1);
#else
	gtk_grid_attach(GTK_GRID(grid_), GTK_WIDGET(drawingarea_), 0, 1, 1, 1);
#endif
	cmdline_entry_ = gtk_entry_new();
	// TODO: GTK-specific autocompletion
	gtk_widget_set_vexpand(GTK_WIDGET(cmdline_entry_), FALSE);
	gtk_widget_set_hexpand(GTK_WIDGET(cmdline_entry_), TRUE);
	gtk_widget_set_valign(GTK_WIDGET(cmdline_entry_), GTK_ALIGN_END);
	gtk_widget_set_margin_top(GTK_WIDGET(cmdline_entry_), 2); // to equalize heights of statusbar_ and cmdline_entry_
	gtk_widget_set_margin_bottom(GTK_WIDGET(cmdline_entry_), 3);
	gtk_widget_set_margin_start(GTK_WIDGET(cmdline_entry_), 0);
	gtk_widget_set_margin_end(GTK_WIDGET(cmdline_entry_), 0);
	gtk_entry_set_has_frame(GTK_ENTRY(cmdline_entry_), FALSE);
#if !FIM_GTK_WITH_RENDERED_STATUSBAR
	gtk_grid_attach_next_to(GTK_GRID(grid_), GTK_WIDGET(cmdline_entry_), GTK_WIDGET(statusbar_), GTK_POS_BOTTOM, 1, 1);
#endif
	g_signal_connect(G_OBJECT(window_), "destroy", G_CALLBACK(
			[]()
			{
				g_object_unref(pixbuf);
				pixbuf = NULL;
				gtk_container_remove (GTK_CONTAINER(grid_), drawingarea_);
				drawingarea_ = NULL;
				last_pressed_key_ = cc.find_keycode_for_bound_cmd(FIM_FLT_QUIT);
			}
		), NULL);
	gtk_container_add(GTK_CONTAINER(window_), grid_);

	g_signal_connect(G_OBJECT(window_), "key-press-event", G_CALLBACK(cb_key_pressed), NULL);
	g_signal_connect(G_OBJECT(window_), "key-release-event", G_CALLBACK(cb_key_pressed), NULL);
	g_signal_connect(G_OBJECT(window_), "window-state-event", G_CALLBACK(cb_window_state_event), NULL);
	g_signal_connect(G_OBJECT(window_), "configure-event", G_CALLBACK(cb_window_event), NULL);
	g_signal_connect(G_OBJECT(drawingarea_), "draw", G_CALLBACK(cb_do_draw), NULL);
	// TODO: handle events in drawingarea_ and cmdline_entry_

	do_rebuild_help_menus();

	accel_group_ = gtk_accel_group_new();
	gtk_window_add_accel_group(GTK_WINDOW(window_), accel_group_);
	keys_setup(sym_keys);
	// TODO: need to populate menus and if needed, rebuild them
	gtk_widget_show_all(GTK_WIDGET(window_));
	gtk_widget_hide(cmdline_entry_);

	gtk_test_widget_wait_for_draw(GTK_WIDGET(window_)); // to get proper window size
	reinit(opts_.c_str());
	FIM_GTK_DBG_COUT << "\n";

	return FIM_ERR_NO_ERROR;
}

static fim_sys_int get_input_inner(fim_key_t * c, GdkEventKey*eventk, fim_sys_int *keypressp, bool want_poll)
{
	if ( last_pressed_key_ )
	{
		FIM_GTK_DBG_COUT << "PRESSED " << last_pressed_key_ << " \n";
	}

	gtk_main_iteration();

	if ( last_pressed_key_ )
	{
		if (want_poll) // hack: only set if in readline mode
			switch (last_pressed_key_)
			{
				case(GDK_KEY_Up):   last_pressed_key_=0x111; break;
				case(GDK_KEY_Down): last_pressed_key_=0x112; break;
				case(GDK_KEY_Right):last_pressed_key_=0x113; break;
				case(GDK_KEY_Left): last_pressed_key_=0x114; break;
			}
		* c = last_pressed_key_;
		last_pressed_key_ = 0; // to emit once is enough
		return 1;
	}
	return 0;
}

fim_coo_t GTKDevice::width() const
{
	// FIXME: temporary
	return gtk_widget_get_allocated_width((GtkWidget*)drawingarea_);
}

fim_coo_t GTKDevice::height() const
{
	// FIXME: temporary
	fim_coo_t h = 0;
	if(drawingarea_)
		h = gtk_widget_get_allocated_height((GtkWidget*)drawingarea_);
	return h;
}

fim_sys_int GTKDevice::get_input(fim_key_t * c, bool want_poll)
{
	int keypress_ = 0;
	GdkEventKey event_;
	const fim_sys_int iv = get_input_inner(c,&event_,&keypress_,want_poll);
	return iv;
}

fim_key_t GTKDevice::catchInteractiveCommand(fim_ts_t seconds)const
{
	/*
	 * after SDLDevice::catchInteractiveCommand()
	 * */
	fim_key_t c=0;
	fim_sys_int lkeypress=0;
	fim_tms_t sms=10,ms=seconds*1000;// sms: sleep ms
	FIM_GTK_INPUT_DEBUG(&c,"");

	if ( gtk_events_pending() )
	{
		gtk_main_iteration();
		goto done;
	}
	else
	do
	{
		if(ms>0)
			usleep((useconds_t)(sms*1000)),ms-=sms;
		// we read input twice: it seems we have a number of "spurious" inputs. 
	}
	while(ms>0);
	return -1;
done:
	usleep((useconds_t)(sms*1000)),ms-=sms;
	return c;
}

fim_key_t GTKDevice::set_wm_caption(const fim_char_t *msg)
{
	const fim_err_t rc = FIM_ERR_NO_ERROR;
	gtk_window_set_title(window_, msg);
	return rc;
}

fim_coo_t GTKDevice::get_chars_per_line() const
{
	return width() / f_->swidth();
}

fim_coo_t GTKDevice::get_chars_per_column(void) const
{
	return height() / f_->sheight();
}

#ifndef FIM_WANT_NO_OUTPUT_CONSOLE
GTKDevice::GTKDevice(MiniConsole& mc_, fim::string opts): DisplayDevice (mc_),
#else /* FIM_WANT_NO_OUTPUT_CONSOLE */
GTKDevice::GTKDevice(fim::string opts):DisplayDevice(),
#endif /* FIM_WANT_NO_OUTPUT_CONSOLE */
	opts_(opts)
{
	FontServer::fb_text_init1(fontname_,&f_);
}

fim_err_t GTKDevice::status_line(const fim_char_t *msg)
{
		// FIXME: need to unify and cleanup together with SDL's and other versions
#if FIM_GTK_WITH_RENDERED_STATUSBAR
		fim_err_t errval = FIM_ERR_NO_ERROR;
		fim_coo_t y,ys=3;// FIXME
		if(get_chars_per_column()<1)
			goto done;
		y = height() - f_->sheight() - ys;
		if(y<0 )
			goto done;
		clear_rect(0, width()-1, y+1,y+f_->sheight()+ys-1);
		fs_puts(f_, 0, y+ys, msg);
		fill_rect(0,width()-1, y, y, FIM_CNS_WHITE);
done:
		gtk_widget_queue_draw(GTK_WIDGET(drawingarea_));
		return errval;
#else
	gtk_statusbar_push(GTK_STATUSBAR(statusbar_), context_id, msg);
	FIM_GTK_DBG_COUT << ":" << msg << "\n";
	return FIM_ERR_NO_ERROR;
#endif
}

fim_err_t GTKDevice::display(
	const void *ida_image_img, // source image structure
	fim_coo_t iroff,fim_coo_t icoff, // row and column offset of the first input pixel
	fim_coo_t irows,fim_coo_t icols,// rows and columns in the input image
	fim_coo_t icskip,	// input columns to skip for each line
	fim_coo_t oroff,fim_coo_t ocoff,// row and column offset of the first output pixel
	fim_coo_t orows,fim_coo_t ocols,// rows and columns to draw in output buffer
	fim_coo_t ocskip,// output columns to skip for each line
	fim_flags_t flags// some flags
)
{
	const fim_coo_t ww_ = width();
	const fim_coo_t wh_ = height();

	FIM_GTK_DBG_COUT << "DISPLAY  ocskip:" << ocskip << "  ocols:" << ocols << " rowstride_/Bpp:" << rowstride_/Bpp_ << "  " << ((rowstride_) == (Bpp_*ocskip)) << "\n";

	fim_byte_t* rgb = ida_image_img?((const struct ida_image*)ida_image_img)->data:FIM_NULL;// source rgb array

	if( iroff <0 ) return -2;
	if( icoff <0 ) return -3;
	if( irows <=0 ) return -4;
	if( icols <=0 ) return -5;
	if( icskip<0 ) return -6;
	if( oroff <0 ) return -7;
	if( ocoff <0 ) return -8;
	if( orows <=0 ) return -9;
	if( ocols <=0 ) return -10;
	if( ocskip<0 ) return -11;
	if( flags <0 ) return -12;

	if( iroff>irows ) return -2-3*100 ;
	if( icoff>icols ) return -3-5*100;
//	if( oroff>orows ) return -7-9*100;//EXP
//	if( ocoff>ocols ) return -8-10*100;//EXP
	if( oroff>height() ) return -7-9*100;//EXP
	if( ocoff>width()) return -8-10*100;//EXP

	if( icskip<icols ) return -6-5*100;
	if( ocskip<ocols ) return -11-10*100;
	
	orows  = FIM_MIN( orows, height());
	ocols  = FIM_MIN( ocols,  width()); 
	ocskip = width(); 	//FIXME maybe this is not enough and should be commented or rewritten!

	if( orows  > height() ) return -9 -99*100;
	if( ocols  >  width() ) return -10-99*100;
	if( ocskip <  width() ) return -11-99*100;
	if( icskip<icols ) return -6-5*100;

	ocskip = width();// output columns to skip for each line

	if(icols<ocols) { ocoff+=(ocols-icols-1)/2; ocols-=(ocols-icols-1)/2; }
	if(irows<orows) { oroff+=(orows-irows-1)/2; orows-=(orows-irows-1)/2; }

	fim_coo_t ytimesw;

	fim_coo_t idr,idc,lor,loc;

	idr = iroff-oroff;
	idc = icoff-ocoff;

	lor = oroff+(FIM_MIN(orows,irows-iroff));
	loc = ocoff+(FIM_MIN(ocols,icols-icoff));

	fim_coo_t ii,ij;
	fim_coo_t oi,oj;
	fim_flags_t mirror=flags&FIM_FLAG_MIRROR, flip=flags&FIM_FLAG_FLIP;//STILL UNUSED : FIXME
	fim_byte_t * srcp;

	clear_rect(  0, width()-1, 0, height()-1); 

	for(oi=oroff;FIM_LIKELY(oi<lor);++oi)
	for(oj=ocoff;FIM_LIKELY(oj<loc);++oj)
	{
		ii    = oi + idr;
		ij    = oj + idc;
		
		if(mirror)ij=((icols-1)-ij);
		if( flip )ii=((irows-1)-ii);
		srcp  = ((fim_byte_t*)rgb)+(Bpp_*(ii*icskip+ij));

		gdk_pixbuf_get_pixels(pixbuf)[rowstride_*oi+Bpp_*(oj)+0]=srcp[2];
		gdk_pixbuf_get_pixels(pixbuf)[rowstride_*oi+Bpp_*(oj)+1]=srcp[1];
		gdk_pixbuf_get_pixels(pixbuf)[rowstride_*oi+Bpp_*(oj)+2]=srcp[0];
	}

	gtk_widget_queue_draw(GTK_WIDGET(window_));
	return FIM_ERR_NO_ERROR;
}

	fim_coo_t GTKDevice::status_line_height(void)const
	{
		return f_ ? border_height_ + f_->sheight() : 0;
	}


	fim_err_t GTKDevice::clear_rect(fim_coo_t x1, fim_coo_t x2, fim_coo_t y1,fim_coo_t y2) FIM_NOEXCEPT
	{
		fim_coo_t y;
		/*
		 * */
		fim_byte_t* rgb = ((fim_byte_t*)(gdk_pixbuf_get_pixels(pixbuf)));

		for(y=y1;y<=y2;++y)
		{
			fim_bzero(rgb + y*(rowstride_) + x1*Bpp_, (x2-x1+1)* Bpp_);
		}
		return FIM_ERR_NO_ERROR;
	}

fim_err_t GTKDevice::fs_puts(struct fs_font *f_, fim_coo_t x, fim_coo_t y, const fim_char_t *str) FIM_NOEXCEPT
{
    fim_sys_int i,c/*,j,w*/;

    for (i = 0; str[i] != '\0'; i++) {
	c = (fim_byte_t)str[i];
	if (FIM_NULL == f_->eindex[c])
	    continue;
	/* clear with bg color */
//	w = (f_->eindex[c]->width+1)*Bpp_;
#if 0
#ifdef FIM_IS_SLOWER_THAN_FBI
	for (j = 0; j < f_->sheight(); j++) {
/////	    memset_combine(start,0x20,w);
	    fim_bzero(start,w);
	    start += fb_fix.line_length;
	}
#else
	//sometimes we can gather multiple calls..
	if(fb_fix.line_length==w)
	{
		//contiguous case
		fim_bzero(start,w*f_->sheight());
	    	start += fb_fix.line_length*f_->sheight();
	}
	else
	for (j = 0; j < f_->sheight(); j++) {
	    fim_bzero(start,w);
	    start += fb_fix.line_length;
	}
#endif
#endif
	/* draw character */
	//fs_render_fb(fb_fix.line_length,f_->eindex[c],f_->gindex[c]);
	fs_render_fb(x,y,f_->eindex[c],f_->gindex[c]);
	x += f_->eindex[c]->swidth();
	/* FIXME : SLOW ! */
	if (((fim_coo_t)x) > width() - f_->swidth())
		goto err;
    }
    // FIXME
	return FIM_ERR_NO_ERROR;
err:
	return FIM_ERR_GENERIC;
}

void GTKDevice::fs_render_fb(fim_coo_t x_, fim_coo_t y, FSXCharInfo *charInfo, fim_byte_t *data) FIM_NOEXCEPT
{
	// FIXME: unify this with other driver's versions
/* 
 * These preprocessor macros should serve *only* for font handling purposes.
 * */
#define BIT_ORDER       BitmapFormatBitOrderMSB
#ifdef BYTE_ORDER
#undef BYTE_ORDER
#endif
#define BYTE_ORDER      BitmapFormatByteOrderMSB
#define SCANLINE_UNIT   BitmapFormatScanlineUnit8
#define SCANLINE_PAD    BitmapFormatScanlinePad8
#define EXTENTS         BitmapFormatImageRectMin

#define SCANLINE_PAD_BYTES 1
#define GLWIDTHBYTESPADDED(bits, nBytes)                                    \
        ((nBytes) == 1 ? (((bits)  +  7) >> 3)          /* pad to 1 byte  */\
        :(nBytes) == 2 ? ((((bits) + 15) >> 3) & ~1)    /* pad to 2 bytes */\
        :(nBytes) == 4 ? ((((bits) + 31) >> 3) & ~3)    /* pad to 4 bytes */\
        :(nBytes) == 8 ? ((((bits) + 63) >> 3) & ~7)    /* pad to 8 bytes */\
        : 0)

	fim_coo_t row,bit,x;
	FIM_CONSTEXPR Uint8 rc = 0xff, gc = 0xff, bc = 0xff;
	// const Uint8 rc = 0x00, gc = 0x00, bc = 0xff;
	const fim_sys_int bpr = GLWIDTHBYTESPADDED((charInfo->right - charInfo->left), SCANLINE_PAD_BYTES);
	const Uint16 incr = rowstride_ / Bpp_;

	fim_byte_t* rgb = ((fim_byte_t*)(gdk_pixbuf_get_pixels(pixbuf)));
	for (row = 0; row < (charInfo->ascent + charInfo->descent); row++)
	{
		for (x = 0, bit = 0; bit < (charInfo->right - charInfo->left); bit++, x++) 
		{
			if (data[bit>>3] & fs_masktab[bit&7])
			{	// WARNING !
#if FIM_FONT_MAGNIFY_FACTOR == 0
				const fim_int fim_fmf = fim::fim_fmf_; 
#endif	/* FIM_FONT_MAGNIFY_FACTOR */
#if FIM_FONT_MAGNIFY_FACTOR <  0
				fim_int fim_fmf = fim::fim_fmf_; 
#endif	/* FIM_FONT_MAGNIFY_FACTOR */
#if FIM_FONT_MAGNIFY_FACTOR == 1
				setpixel(rgb,x_+x,(y+row),rc,gc,bc);
#else	/* FIM_FONT_MAGNIFY_FACTOR */
				for(fim_coo_t mi = 0; mi < fim_fmf; ++mi)
				for(fim_coo_t mj = 0; mj < fim_fmf; ++mj)
					setpixel(rgb,x_+fim_fmf*x+mj,(y+fim_fmf*row+mi),rc,gc,bc);
#endif	/* FIM_FONT_MAGNIFY_FACTOR */
			}
		}
		data += bpr;
	}

#undef BIT_ORDER
#undef BYTE_ORDER
#undef SCANLINE_UNIT
#undef SCANLINE_PAD
#undef EXTENTS
#undef SCANLINE_PAD_BYTES
#undef GLWIDTHBYTESPADDED
}

void GTKDevice::setpixel(fim_byte_t* rgb, fim_coo_t x, fim_coo_t y, fim_byte_t r, fim_byte_t g, fim_byte_t b)
{
	// style modified from other drivers; would need some unity and cleanliness though
	rgb += y * rowstride_ + x * Bpp_;
	rgb[0] = r;
	rgb[1] = g;
	rgb[2] = b;
}

fim_err_t GTKDevice::fill_rect(fim_coo_t x1, fim_coo_t x2, fim_coo_t y1,fim_coo_t y2, fim_color_t color) FIM_NOEXCEPT
{
	fim_coo_t y;
	/*
	 * This could be optimized
	 * */
	fim_byte_t* rgb = ((fim_byte_t*)(gdk_pixbuf_get_pixels(pixbuf)));

	for(y=y1;y<=y2;++y)
	{
		fim_memset(rgb + y*rowstride_ + x1*Bpp_,color, (x2-x1+1)* Bpp_);
	}
	return FIM_ERR_NO_ERROR;
}

	fim_err_t GTKDevice::reinit(const fim_char_t *rs)
	{
		FIM_GTK_DBG_COUT << ":" << rs << "\n";

		if (strchr(rs, 'W'))
			full_screen_=1;
		else
			full_screen_=0;
		toggle_fullscreen(full_screen_);

		if (strchr(rs, 'b'))
			show_menubar_=0;
		else
			show_menubar_=1;

		if ( show_menubar_ )
			gtk_widget_show_all (menubar_);
		else
			gtk_widget_hide (menubar_);

		if ( cc.display_resize(nw_,nh_) == FIM_ERR_NO_ERROR )
		{
			// opts_ = rs;
			return FIM_ERR_NO_ERROR;
		}
		return FIM_ERR_GENERIC;
	}

#endif /* FIM_WITH_LIBGTK */
#pragma GCC pop_options
