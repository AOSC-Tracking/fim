.\"
.\" $Id$
.\"
.TH fimrc 1 "(c) 2011-2011 Michele Martone"
.SH NAME
fimrc - \fB fim \fP configuration file and language reference

.SH SYNOPSIS
.B ~/.fimrc
.fi
.B /etc/fimrc
.fi
.B fim --script-from-stdin [ options ] < {scriptfile}
.fi
.B fim --execute-script {scriptfile} [ options ]
.fi
.B fim --execute-commands {commands} [ options ]
.fi
.B fim --final-commands {commands} [ options ]
.fi
.B fim --write-scriptout {scriptfile} [ options ]  
.fi
.B fim --write-scriptout /dev/stdout [ options ]
.fi

.SH DESCRIPTION
This page explains the 
.B fim
language, which is used for the 
.B fimrc
configuration files, {scriptfile}s, or {commands} passed via command line options.
This language can be used to issue commands (or programs) from the internal program command line accessed interactively through the ":" key.
The general form of a fim command/program is shown in the next section.


.SH FIM LANGUAGE GRAMMAR
This section specifies the grammar of the 
.B fim
language.

Language elements surrounded by a single quote ("'") are literals.

Warning: at the present state, this grammar has conflicts. A next release shall fix them.

  program:
         | statement_list

  statement_list: statement
                | statement ';' statement_list
                | non_atomic_statements_block statement_list
                | statements_block

  non_atomic_statements_block: '{' statement_list '}'
                             | INTEGER '{' statement_list '}'
                             | conditional_statement

  statements_block: atomic_statements_block
                  | non_atomic_statements_block

  conditional_statement: if_statement
                       | loop_statement

  if_statement: 'if' '(' expression ')' statements_block
              | 'if' '(' expression ')' statements_block 'else' statements_block

  loop_statement: 'while' '(' expression ')' statements_block
                | 'do' statements_block 'while' '(' expression ')'

  atomic_statements_block: statement ';'
                         | statement ';' ';'
                         | statement ';' ';' ';'

  statement: '!' arguments
           | INTEGER IDENTIFIER
           | SLASH_AND_REGEXP
           | '+' UNQUOTED_FLOAT '%'
           | '+' QUOTED_FLOAT '%'
           | '+' INTEGER '%'
           | '*' UNQUOTED_FLOAT
           | '*' QUOTED_FLOAT
           | '*' INTEGER
           | UNQUOTED_FLOAT '%'
           | QUOTED_FLOAT '%'
           | INTEGER '%'
           | '-' UNQUOTED_FLOAT '%'
           | '-' QUOTED_FLOAT '%'
           | '-' INTEGER '%'
           | INTEGER
           | IDENTIFIER
           | IDENTIFIER FILE_PATH
           | IDENTIFIER arguments
           | INTEGER IDENTIFIER arguments
           | IDENTIFIER '=' expression

  arguments: expression
           | expression arguments

  expression: '(' expression ')'
            | expression '.' expression
            | '!' expression
            | expression '%' expression
            | expression '+' expression
            | expression '-' expression
            | expression '*' expression
            | expression '/' expression
            | expression '<' expression
            | expression '>' expression
            | expression '||' expression
            | expression '&&' expression
            | expression '>=' expression
            | expression '<=' expression
            | expression '!=' expression
            | expression '==' expression
            | expression '=~' expression
            | '-' expression
            | IDENTIFIER
            | INTEGER
            | QUOTED_FLOAT
            | UNQUOTED_FLOAT
            | STRING

A STRING can be either a single quoted string or a double quoted string.
A FLOAT is a floating point number.
A QUOTED_FLOAT is a floating point number, either single ("'") or double (""") quoted.
An INTEGER shall be an unsigned integer number.
An IDENTIFIER shall be one of the valid fim commands (see 
.B COMMANDS REFERENCE
) or a valid alias.
A VARIABLE shall be an already declared or undeclared variable identifier (see 
.B VARIABLES REFERENCE
) or a valid alias, created using the 
.B alias
command.
The "=~" operator treats the right expression as a STRING, and uses is as a regular expression for matching purposes.
The SLASH_AND_REGEXP is a slash ("/") followed by a STRING, interpreted as a regular expression.
See regex(1) for regular expression syntax.

The way some one-line statements are evaluated:

.nf
:{number}       jump to {number}^th image in the list
:^	        jump to first image in the list
:$	        jump to last image in the list
:*{factor}      scale the image by {factor}
:{scale}%       scale the image to the desired {scale}
:+{scale}%       scale the image up to the desired percentage {scale} (relatively to the original)
:-{scale}%       scale the image down to the desired percentage {scale} (relatively to the original)

/{regexp}		 entering the pattern {regexp} (with /) makes fim jump to the next image whose filename matches {regexp}
/*.png$		 entering this pattern (with /) makes fim jump to the next image whose filename ends with 'png'
/png		 a shortcut for /.*png.*

!{syscmd}		executes the {syscmd} quoted string as a "/bin/sh" shell command


.SH COMMANDS REFERENCE

.B
prefetch
.fi
prefetch : prefetch two nearby image files, for a faster subsequent opening
.fi

.B
next
.fi
next [{number}=1] : go to the next picture in the list
.fi

.B
next_picture
.fi
next_picture [{number}=1] : go to the next page or picture file
.fi

.B
prev_picture
.fi
prev_picture [{number}=1] : go to the previous page or picture file
.fi

.B
prev
.fi
prev [{number}=1] : go to the previous picture in the list
.fi

.B
next_page
.fi
next_page [{number}=1] : go to the next page
.fi

.B
prev_page
.fi
prev_page [{number}=1] : go to the previous page
.fi

.B
push
.fi
push {filename(s)} : push {filename(s)} to the back of the files list
.fi

.B
display
.fi
display : display the current file contents
.fi

.B
redisplay
.fi
redisplay : re-display the current file contents
.fi

.B
list
.fi
list : display the files list
.fi

.B
pop
.fi
pop : pop the last file from the files list
.fi

.B
file
.fi
file : display the current file's name in the console
.fi

.B
pan_ne
.fi
pan the image north east [undocumented]
.fi

.B
pan_nw
.fi
pan the image north west [undocumented]
.fi

.B
pan_sw
.fi
pan the image south west [undocumented]
.fi

.B
pan_se
.fi
pan the image south east [undocumented]
.fi

.B
panup
.fi
pan the image up [undocumented]
.fi

.B
pandown
.fi
pan the image down [undocumented]
.fi

.B
panleft
.fi
pan the image left [undocumented]
.fi

.B
panright
.fi
pan the image right [undocumented]
.fi

.B
load
.fi
load : load the image, if not yet loaded
.fi

.B
reload
.fi
reload : load the image into memory
.fi

.B
files
.fi
files : display the number of files in the file list
.fi

.B
sort
.fi
sort : sort the file list
.fi

.B
random_shuffle
.fi
random_shuffle : randomly shuffle the file list
.fi

.B
reverse
.fi
reverse : reverse the file list
.fi

.B
remove
.fi
remove [{filename(s)}] : remove the current file, or the {filename(s)}, if specified
.fi

.B
info
.fi
info : display information about the current file
.fi

.B
regexp_goto
.fi
regexp_goto {regexp} : jump to the first image matching the given {regexp} pattern
.fi

.B
regexp_goto_next
.fi
regexp_goto_next : jump to the next image matching the last given pattern
.fi

.B
scale_increment
.fi
scale_increment : increment the scale by a percentual amount [undocumented]
.fi

.B
scale_multiply
.fi
scale_multiply : multiply the scale by the specified amount [undocumented]
.fi

.B
scale_factor_grow
.fi
multiply the scale factors reduce_factor and magnify_factor by scale_factor_multiplier [undocumented]
.fi

.B
scale_factor_shrink
.fi
divide the scale factors reduce_factor and magnify_factor by scale_factor_multiplier [undocumented]
.fi

.B
scale_factor_increase
.fi
add scale_factor_delta to the scale factors reduce_factor and magnify_factor [undocumented]
.fi

.B
scale_factor_decrease
.fi
subtract scale_factor_delta to the scale factors reduce_factor and magnify_factor  [undocumented]
.fi

.B
rotate
.fi
rotate {number}: rotate the image the specified amount of degrees [undocumented]
.fi

.B
magnify
.fi
magnify : magnify the displayed image by the magnify_factor variable or {args} [undocumented]
.fi

.B
reduce
.fi
reduce : reduce the displayed image by reduce_factor or {args} [undocumented]
.fi

.B
return
.fi
return {number} : return from the program with a specified status code
.fi

.B
align_top
.fi
align_top : align to the upper side the current image
.fi

.B
align_bottom
.fi
align_bottom : align to the lower side the current image
.fi

.B
goto
.fi
goto {number} : go to the image specified by index {number}
.fi

.B
negate
.fi
negate : negate the displayed image colors
.fi

.B
status
.fi
status : set the status line to the collation of the given arguments
.fi

.B
scrolldown
.fi
scrolldown : scroll down the image, going next if at bottom
.fi

.B
scrollforward
.fi
scrollforward : scroll the image as it were reading it
.fi

.B
scale
.fi
scale : scale the image according to a scale (ex.: 0.5,40%,..) [undocumented]
.fi

.B
set
.fi
set : manipulate the internal variables [undocumented]
.fi

.B
auto_scale
.fi
auto_scale : set auto scale mode
.fi

.B
auto_width_scale
.fi
auto_width_scale : scale the image so that it fits horizontally in the screen
.fi

.B
auto_height_scale
.fi
auto_height_scale : scale the image so that it fits vertically in the screen
.fi

.B
bind
.fi
bind [{keysym} [{commands}]] : bind some keyboard shortcut {keysym} to {commands}; if {keysym} is at least two characters long and begins with 0 (zero), the integer number after the 0 will be treated as a raw keycode to bind the specified {keysym} to. activate the _verbose_keys variable to discover (display device dependent) raw keys.
.fi

.B
quit
.fi
quit : terminate the program
.fi

.B
exec
.fi
exec {filename(s)} : execute script {filename(s)}
.fi

.B
echo
.fi
echo {args}: print the {args} on console
.fi

.B
if
.fi
if(expression){action;}[else{action;}]
.fi

.B
else
.fi
if(expression){action;}[else{action;}]
.fi

.B
while
.fi
while(expression){action;}
.fi

.B
alias
.fi
alias [{identifier} [{commands} [{description}]]]
.fi

.B
getenv
.fi
getenv {identifier} : display the value of the {identifier} environment variable
.fi

.B
unalias
.fi
unalias {identifier} | "-a" : delete the alias {identifier} or all aliases (use "-a", not -a)
.fi

.B
unbind
.fi
unbind {keysym} : unbind the action associated to a specified {keysym}; if {keysym} is at least two characters long and begins with 0 (zero), the integer number after the 0 will be treated as a raw keycode to bind the specified {keysym} to. activate the _verbose_keys variable to discover (display device dependent) raw keys.
.fi

.B
sleep
.fi
sleep [{number}=1] : sleep for the specified (default 1) number of seconds
.fi

.B
mark
.fi
mark : mark the current file for stdout printing at exit
.fi

.B
unmark
.fi
unmark : unmark the current file for stdout printing at exit
.fi

.B
help
.fi
help [{identifier}] : provide online help, if {identifier} is some variable, alias, or command identifier
.fi

.B
autocmd
.fi
autocmd {event} {pattern} {commands} : manipulate auto commands
.fi

.B
autocmd_del
.fi
autocmd_del : manipulate auto commands. usage: autocmd_del {event} {pattern} {commands}
.fi

.B
set_interactive_mode
.fi
set_interactive_mode : set interactive mode
.fi

.B
set_console_mode
.fi
set_console_mode : set console mode
.fi

.B
system
.fi
system {syscmd}: get the output of the shell command {syscmd}. (uses popen()
.fi

.B
cd
.fi
cd {path}: change the current directory to {path}. cd - will change to the previous current directory (before the last ":cd {path}" command)
.fi

.B
pwd
.fi
pwd : print the current directory name.
.fi

.B
popen
.fi
popen {syscmd} : pipe a command, invoking popen(): spawns a shell, invoking {syscmd} and executing as fim commands the output of {syscmd}
.fi

.B
stdout
.fi
stdout {args} : writes to stdout its arguments {args}
.fi

.B
start_recording
.fi
start_recording : start recording the executed commands
.fi

.B
stop_recording
.fi
stop_recording : stops recording the executed commands
.fi

.B
dump_record_buffer
.fi
dump_record_buffer : dump in the console the record buffer
.fi

.B
execute_record_buffer
.fi
execute_record_buffer : execute the record buffer
.fi

.B
eval
.fi
eval {args} : evaluate {args} as commands, executing them.
.fi

.B
repeat_last
.fi
repeat_last : repeat the last performed action
.fi

.B
variables
.fi
variables : display the existing variables
.fi

.B
commands
.fi
commands : display the existing commands
.fi

.B
dump_key_codes
.fi
dump_key_codes : dump the active key codes (unescaped, for inspection)
.fi

.B
clear
.fi
clear : clear the virtual console
.fi

.B
window
.fi
window {args} : manipulates the window system windows; each value of {args} shall be one of [ split | hsplit | vsplit | normalize | enlarge | venlarge | henlarge | up | down | left | right | close | swap ]
.fi

.SH VARIABLES REFERENCE
If undeclared, a variable will evaluate to 0.
In the following, the [internal] variables are the ones referenced in the source code (not including the hardcoded configuration, which may be inspected and/or invalidated by the user at runtime).

.B
FIM_DEFAULT_CONFIG_FILE_CONTENTS
[internal,out] the contents of the default (hardcoded) configuration file
.fi
.B
FIM_DEFAULT_GRAMMAR_FILE_CONTENTS
[internal,out] the contents of the default (hardcoded) grammar file
.fi
.B
_TERM
[internal,out] the environment TERM variable
.fi
.B
_autocmd_trace_stack
[internal] dump to stdout autocommands stack trace during their execution (for debugging purposes)
.fi
.B
_cache_status
[internal,out] current information on cache status
.fi
.B
_cached_images
[internal,out] the number of images currently cached
.fi
.B
_debug_commands
[internal] each executed command (for debugging purposes)
.fi
.B
_device_string
[internal,out] the current device string
.fi
.B
_display_as_binary
[internal,in] if nonzero, will force loading of the specified files as pixelmaps (no image decoding will be performed); if 1, using one bit per pixel;  if 24, using 24 bits per pixel; otherwise will load and decode the files as usual
.fi
.B
_display_busy
[internal,in] if 1, will display a message on the status bar when processing
.fi
.B
_display_console
[internal,in] if 1, will display the output console
.fi
.B
_display_status
[internal,in] if 1, will display the status bar
.fi
.B
_display_status_bar
[internal,in] if 1, will display the status bar
.fi
.B
_do_sanity_check
[internal,in,experimental] if 1, will execute a sanity check on startup
.fi
.B
_fim_bpp
[internal,out] the bits per pixel count
.fi
.B
_fim_scriptout_file
[internal,in] the name of the file to write to when recording sessions
.fi
.B
_last_system_output
[internal,out,experimental] the standard output of the last call to the system command
.fi
.B
_load_default_etc_fimrc
[internal,in] if 1 at startup, will load /etc/fimrc, or equivalent system startup file
.fi
.B
_load_fim_history
[internal,in] if 1 on startup, will load the ~/fim_history file on startup
.fi
.B
_max_cached_images
[internal,in] the maximum number of images allowed in the cache
.fi
.B
_max_cached_memory
[internal,in] the maximum amount of memory allowed for the cache
.fi
.B
_max_iterated_commands
[internal,experimental] the iteration limit for N in "N[commandname]" iterated command invocations
.fi
.B
_no_default_configuration
[internal,in]
.fi
.B
_no_external_loader_programs
[internal,in] if not 0, no external loading programs will be tried for piping in an unsupported type image file
.fi
.B
_no_rc_file
[internal,in] if not 0, the ~/.fimrc file will not be loaded at startup
.fi
.B
_open_offset
[internal,undocumented] offset used when opening files
.fi
.B
_override_display
[internal,undocumented]
.fi
.B
_save_fim_history
[internal,in] if 1 on exit, will save the ~/fim_history file on exit
.fi
.B
_seek_magic
[internal,undocumented] will seek for a magic signature before opening a file (for now, use like this: fim -c '_seek_magic=MAGIC_STRING;push file_to_seek_in.ext' ) 
.fi
.B
_status_line
[internal,in] if 1, will display the status bar
.fi
.B
_verbose_errors
[internal,in,undocumented]
.fi
.B
_verbose_keys
[internal,in] if non zero, after each interactive mode key hit, the console will display the hit key raw keycode
.fi
.B
_want_prefetch
[internal,in] if 1, will prefetch further files just after display of the first file
.fi
.B
angle
[internal,undocumented]
.fi
.B
ascale
[internal,in] the asymmetric scaling of the current image
.fi
.B
auto_scale_v
[experimental, undocumented]
.fi
.B
autoflip
[internal,undocumented]
.fi
.B
automirror
[internal,undocumented]
.fi
.B
autonegate
[internal,undocumented]
.fi
.B
autotop
[internal,in] if 1, will align to the top freshly loaded images
.fi
.B
autowidth
[internal,in] if 1, will scale freshly loaded images to fit width
.fi
.B
comment
[internal,out] the image comment, stored in the image file
.fi
.B
console_buffer_free
[internal,in,undocumented]
.fi
.B
console_buffer_total
[internal,in,undocumented]
.fi
.B
console_buffer_used
[internal,in,undocumented]
.fi
.B
console_key
[internal,in] the key binding for spawning the command line [internal]
.fi
.B
console_lines
[internal,in,undocumented]
.fi
.B
console_offset
[internal,in,undocumented]
.fi
.B
fileindex
[internal,out] the current image numeric index
.fi
.B
filelistlen
[internal,out] the length of the current image list
.fi
.B
filename
[internal,out] the current file name
.fi
.B
flipped
[internal,undocumented]
.fi
.B
fresh
[internal,in,out,experimental] 1 if the image was loaded, before all autocommands execution
.fi
.B
height
[internal,out] the current image original height
.fi
.B
ignorecase
[internal,in] if 1, will allow for case insensitive regexp searches
.fi
.B
lwidth
[internal,in,undocumented]
.fi
.B
magnify_factor
[internal,in] the image scale multiplier used when magnifying images size
.fi
.B
mirrored
[internal,undocumented]
.fi
.B
negated
[internal,undocumented]
.fi
.B
orientation
[internal,undocumented]
.fi
.B
pwd
[internal,out] the current working directory
.fi
.B
random
[internal,out] a pseudorandom number
.fi
.B
reduce_factor
[internal,in] the image scale multiplier used when reducing images size
.fi
.B
rows
[internal,in,undocumented]
.fi
.B
scale
[internal,in] the scale of the current image
.fi
.B
scale_factor_delta
[internal,undocumented]
.fi
.B
scale_factor_multiplier
[internal,undocumented]
.fi
.B
screen_height
[internal,out] the screen height
.fi
.B
screen_width
[internal,out] the screen width
.fi
.B
sheight
[internal,out] the current image scaled height
.fi
.B
steps
[internal,in] the steps, in pixels, when panning images
.fi
.B
swidth
[internal,out] the current image scaled width
.fi
.B
want_autocenter
[internal,undocumented]
.fi
.B
width
[internal,out] the current image original width
.fi
.SH USAGE EXAMPLES
.nf
# jump to the third image:
3;
# jump to first image:
^;
# jump to last image:
$;
# magnify the image two times:
*2;
# scale the image to the 30% of the original:
30%;
# scale the image up by 30%:
+30%;
# scale the image down by 30%:
-30%;
# jump to the next image whose filename matches the ".*jpg" regular expression:
/.*jpg;
# executes the "date" system command
!"date";

.SH CONFIGURATION EXAMPLES
This is the default configuration, as contained in the FIM_DEFAULT_CONFIG_FILE_CONTENTS variable.

.nf
# $Id: fimrc 364 2011-05-28 09:57:03Z dezperado $
# Contents of the default 'fimrc' file, hardcoded in the fim executable.
# Read the documentation to discover how to change this default hardcoded file 
# and how to make your own.
# Note that usually a ~/.fimrc file is read after these options take effect, so you could reset all of this with ease.
# Lines begining with a pound (#) are ignored by fim (they are treated as comments).

#autocmd "Prev" ""  "echo 'PREV'" ;
#autocmd "Prev" "1"  "echo 'PREV1'" ;
#autocmd "Prev" "2"  "echo 'PREV2'" ;
#autocmd "Next" ""  "echo 'NEXT'" ;
#quit;
#info;
#next;
#autocmd;
#bind 29 "scale_factor_increase";
#bind 31 "scale_factor_decrease";
#bind 29 "scale_factor_grow";
#bind 31 "scale_factor_shrink";

# Warning : binding to C-s, C-z and C-c won't make effect, as these
# codes are catched by the console driver and will have no effect in fim.
# Moreover, C-z will crash fim and C-c will terminate it.

# some of these variables influence Fim's behaviour (in the sense these are 'internal')
_display_status=0;
_max_cached_images=5;
_max_cached_memory=80000000;	# not yet functional
_max_iterated_commands=100;
_want_prefetch=1;
_no_external_loader_programs=0;
autowidth=1;
ignorecase=1;
ascale="1.0";
console_offset=0;
_save_fim_history=1;
_load_fim_history=1;

# useful aliases
alias "toggleautoflip" "autoflip=1-autoflip;" "";
alias "toggleautonegate" "autonegate=1-autonegate;" "";
alias "toggleflip" "i:flipped=1-i:flipped;" "";
alias "flip" "toggleflip;redisplay;" "flip the current image along the horizontal axis";
alias "fliponce" "flip;toggleflip;" "";
alias "toggleautomirror" "automirror=1-automirror;" "";
alias "togglemirror" "i:mirrored=1-i:mirrored;" "";
alias "mirror" "togglemirror;redisplay;" "mirror the image along the vertical axis" "";
alias "mirroronce" "mirror;togglemirror;" "";
alias "q" "quit;" "quits the fim program";

# default bindings (binding is dynamical, so you can rebind keys even during program's execution)
bind 'f' "flip;";
bind 'F' "fliponce;";
bind 'm' "mirror;";
bind 'M' "mirroronce;";
bind 'q' "quit";
bind 'Esc' "quit";
#bind 'f' "file";
bind 'n' "next_picture;";
#bind 'h' "help";
bind 'C-h' "help";
bind 'x' "echo";
bind 'e' "echo";
#bind 'p' "prev;display;";
bind 'p' "prev_picture;";
bind 'P' "pop";
bind 's' "sort";
bind 'C-s' "swap;redisplay;";
bind 'S' "toggleDisplayStatus";
bind 'I' "toggleautonegate";
#bind 'R' "reload";
#bind 'R' "redisplay";
#bind 'r' "rotate90";
bind 'R' "rotate10;display;";
bind 'r' "rotate10_ccw;display;";
#bind 'C-d' "display";
bind '+' "magnify";
#bind 'C-+' "angle=angle+10.0;display;";
bind 'a' "auto_scale;";
bind 'Tab' "toggleVerbosity";
bind 'C-v' "toggleKeyVerbosity";
#bind 'C-k' "toggleKeyVerbosity";
bind 'v' "toggleDisplayStatus";
bind 'A' "A";
bind 'C-m' "mark";
bind 'u' "unmark";

# Note : on many consoles C-j is by default equivalent to Enter.. so this could not work :)
bind 'Enter' "mark;next";
bind '-' "reduce";
bind "Up" "panup";
bind 'k' "panup";
bind "Right" "panright";
bind 'l' "panright";
bind "Down" "pandown";
bind 'j' "pandown";
bind "Left" "panleft";
bind 'h' "panleft";
bind ' ' "scrolldown";
bind 't' "align_top;";
#bind "PageUp" "prev_picture;";
#bind "PageDown" "next_picture;";
bind 'i' "info";
bind 'P' "f=`files`/2;prev  --f";
bind 'N' "f=`files`/2;next  --f";

bind 'C-g' "system 'fbgrab fim.png'";
bind 'C-r' "start_recording;";
bind 'Q' "stop_recording";
bind 'D' "dump_record_buffer;";
bind 'E' "execute_record_buffer;";
bind 'C-e' "execute_record_buffer;";
#bind 'C-x' "execute_record_buffer;";
bind 'X' "execute_record_buffer;";
bind '.' "repeat_last;";

#reload;
#_display_status=1;
#display;
alias 'A' "'autotop=1-autotop;'" "";
alias "toggleVerbosity" "_display_console=1-_display_console;i:fresh=1;redisplay;" "";

# key echo
alias "toggleKeyVerbosity" "_verbose_keys=1-_verbose_keys;redisplay;" "";

v:auto_scale_v=1;
_verbose_keys=0;
_display_busy=1;
_display_status=1;
#_verbose_keys=1;

# autocommands are essential to Fim's automated behaviour
#autocmd "Next"     "" "echo 'rendering next image..'";
#autocmd "Prev"     "" "echo 'rendering prev image..'";
#autocmd "PostDisplay" "" "echo '\nthis is a file\n'";
#autocmd "PostGoto"   "" "set_interactive_mode;";
autocmd "PostGoto" "" "reload;";
autocmd "PostNext" "" "reload;";
autocmd "PostPrev" "" "reload;";
#autocmd "PostDisplay"   "" "i:fresh=1" ;
#autocmd "PreWindow"   "" "";
autocmd "PostWindow"   "" "display;";
autocmd "PreRedisplay"   "" "i:_will_display=1;";
autocmd "PreRedisplay"   ".*/fbps-.*" "if(i:fresh){i:fresh=0;auto_width_scale;i:fresh=0;}";
autocmd "PreRedisplay"   "" "if(autowidth*i:fresh){i:fresh=0;auto_width_scale;i:fresh=0;}";
autocmd "PreRedisplay"   "" "if(v:auto_scale_v *i:fresh){i:fresh=0;auto_scale       ;i:fresh=0;}";
autocmd "PreRedisplay"   "" "if(auto_width_v *i:fresh){i:fresh=0;auto_scale_width ;i:fresh=0;}";
autocmd "PreRedisplay"   "" "if(auto_height_v*i:fresh){i:fresh=0;auto_scale_height;i:fresh=0;}";
autocmd "PostRedisplay" ""   "i:_will_display=0;";


# the aalib library has often problems with proportions, and this is a temporary fix
alias "aalib_fix_do" "{ascale='2.0';i:fresh=1;display;steps=5;if(_TERM=~'screen'){echo 'screen+aalib?expect binding problems!'}}" "";
alias "aalib_fix" "if(_device_string=='aalib'){aalib_fix_do;auto_scale;}" "";
#alias "exif_fix" "i:orientation=exif_orientation;exif_orientation='';i:mirrored=exif_mirrored;exif_mirrored='';i:flipped=exif_flipped;exif_flipped='';" "";
#autocmd "PostReload"   "" "aalib_fix;exif_fix;";
#autocmd "PostLoad"   "" "aalib_fix;exif_fix;";
autocmd "PostReload"   "" "aalib_fix;";
autocmd "PostLoad"   "" "aalib_fix;";


autocmd "PostReload"  "" "i:fresh=1" ;
autocmd "PostScale"   "" "if(0==i:_will_display){i:fresh=1;display;}" ;
#autocmd "PostScale"   "" "{i:fresh=1;display;}" ;
autocmd "PostScale"   "" "_wd=i:_will_display;" ;
autocmd "PostPan"     "" "{i:fresh=1;display;}" ;
autocmd "PostReload"   "" "if(i:fresh){redisplay;}";
# FIXME : seems like the following automcd's can be commented
autocmd "PostInteractiveCommand"   "" "if(i:fresh){display;i:fresh=0;}";
autocmd "PostInteractiveCommand"   "" "if(_want_prefetch){prefetch;}";	# new : for smoother browsing of big images 
autocmd "PostInteractiveCommand"   "" "if(_display_console==0 && i:fresh){redisplay;i:fresh=0;}"; # a fixup

alias "next10" "i=0;while(i<10){i=i+1;next;display;sleep '1';};" "goes forward 10 images";
bind 'N' 'next10';
bind 'C-n' "regexp_goto_next";
alias "endless_slideshow" "while(1){display;sleep '1';next;};" "performs an automated slideshow, endlessly";
alias "bookview"          "while(1){display;sleep '2';scrolldown;};" "";
alias "comicview"         "while(1){display;sleep '1';scrolldown;};" "";
alias "read"              "while(1){display;sleep '1';scrollforward;};" "";
alias "slowread"          "while(1){display;sleep '2';scrollforward;};" "";
alias "fastread"          "while(1){display;scrollforward;};" "";
alias "pornview"          "echo 'press any key repeatedly to terminate' ;endless_slideshow;" "";
bind  "C-p" "pornview";
bind  "C-b" "bookview";
autocmd "PreExecutionCycle" "/fbps-" "_display_busy=0;_display_status=0;" ;
autocmd "PreExecutionCycle" "" "i:fresh=1;reload;";
#autocmd "PreExecutionCycle" "" "redisplay;";
autocmd "PreExecutionCycle" "/fbps-.*ps001.png" "i:fresh=1;redisplay;";
#autocmd "PostInteractiveCommand" "" "i:fresh=0;";
#autocmd "PostInteractiveCommand" "" "prefetch;";
#extra..
bind 'w' "auto_width_scale";
bind 'h' "auto_height_scale";
alias "diagonal_nw" "pan_nw;" "pans the image to the upper left";
alias "diagonal_ne" "pan_ne;" "pans the image to the upper right";
alias "diagonal_se" "pan_se;" "pans the image to the lower left";
alias "diagonal_sw" "pan_sw;" "pans the image to the lower right";
bind 'd' "diagonal_nw;";
bind 'D' "diagonal_se;";
bind 'x' "diagonal_ne;";
bind 'X' "diagonal_sw;";
alias "toggleDisplayStatus" "_display_status=1-_display_status;" "";
alias "toggleDisplayBusy" "_display_busy=1-_display_busy;" "";
#bind 'C-a' "auto_scale";
#autocmd "PostInteractiveCommand" "fim.png" "echo '\nmatched an interactive command on fim.png\n';";
#autocmd "PostDisplay" ".*png" "echo 'this is a png file';";
#autocmd "PostDisplay" ".*jpg" "echo 'this is a jpg file';";
#autocmd "PostDisplay" ".*gif" "echo 'this is a gif file';";
####_display_status=1;
#push "media/fim.png";
#push "media/image.png";
#push "media/image.jpg";
#push "media/icon_smile.gif";
echo "WELCOME : to switch to the command line interface press ':' ";
alias "toggleAutoScale" "v:auto_scale_v=1-v:auto_scale_v;autowidth=0;reload;" "";
alias "toggleAutoWidth" "autowidth=1-autowidth;v:auto_scale_v=0;reload;" "";
bind 'C-w'   'toggleAutoWidth;';
bind 'C-a' "toggleAutoScale;";
bind 'C-c' "toggleAutoScale;";
#bind 'C-l' "clear;";	# temporarily off : FIXME
bind 'A'   "toggleAutoScale;";
#toggleVerbosity;
#bind 'f' "next;display;";
bind 'b' "prev;display;";
bind 'B' "toggleDisplayBusy";
alias "plisten" 'popen "nc -l -p 9999 "' "executes fim commands coming from port 9999 on this computer";
alias "wlisten" "while(1){sleep;plisten;}" "listen to a pipe, endlessly";
alias "random_slideshow" "while(1){goto random;}" "performs a shuffled slideshow";
alias "rotate90_ccw" "i:orientation=i:orientation+1;i:fresh=1;i:i:fresh=1;redisplay;" "";
alias "rotate90_cw"  "i:orientation=i:orientation+3;i:fresh=1;i:i:fresh=1;redisplay;" "";
alias "rotate90" "rotate90_cw;display;" "";
alias "rotate10"     "rotate  '10';display;" "";
alias "rotate10_ccw" "rotate -10;display;" "";

# window related aliases and commands
alias "wu" "window 'up'" "selects the window upwards the current";
alias "wd" "window 'down'" "selects the window under the current";
alias "wl" "window 'left'" "selects the window at left of the current";
alias "wr" "window 'right'" "selects the window at right of the current";
bind 'K' "wu";
# Note : on many consoles C-j is by default equivalent to Enter.. so this could not work :)
#bind 'C-j' "wd";
bind 'J' "wd";
bind 'H' "wl";
bind 'L' "wr";
alias "split" "window 'split'" "split the current window horizontally";
alias "vsplit" "window 'vsplit'" "split the current window vertically";
alias "swap" "window 'swap'" "swap the enclosing window subwindows";
alias "ws " "window 'swap'" "see swap";
bind 'T' "split;redisplay;";
#don't use C-s : it will be usually catched by the console driver, and fim won't get it!
#bind 'C-s' "split;";
bind 'V' "vsplit;redisplay;";
bind 'U' "swap;redisplay;";
alias 'venlarge' 'window "venlarge"' "";
alias 'henlarge' 'window "henlarge"' "";
# hmmmm we are out of combinations !

alias 'wnormalize' 'window "normalize"' "";
alias 'wclose' 'window "close"' "";
alias 'wc' 'window "close"' "closes the current window";
bind  'C' "wc;redisplay;";

alias 'cache' 'echo _cache_status;' "displays cached images status";
bind 'c' 'cache;';

alias 'widen'  'i:ascale=i:ascale*"1.1";*1.0;' "widen the current image";
alias 'narrow' 'i:ascale=i:ascale/"1.1";*1.0;' "narrow the current image";
bind  'y' "widen" "widens horizontally the image";
bind  'Y' "narrow" "shrinks horizontally the image";
#alias 'scu'   'scroll_console_up;'   "";
#alias 'scd'   'scroll_console_down;' "";
#alias 'console_scroll_up'   'if(console_offset<console_lines){console_offset=console_offset+1;}';
#alias 'console_scroll_down' 'if(console_offset>0){console_offset=console_offset-1;}';
alias 'console_scroll_up' 'if(console_offset<console_lines+__console_scroll_n-rows){console_offset=console_offset+__console_scroll_n;}';
#__console_scroll_n=rows;
__console_scroll_n=3;
__allow_round_scroll=0;
alias 'console_scroll_down' 'if(__allow_round_scroll || (console_offset>=__console_scroll_n)){console_offset=console_offset-__console_scroll_n;}';
alias 'console_scroll_reset' '{console_offset=0;}';
alias 'scu'   'console_scroll_up;'   "";
alias 'scd'   'console_scroll_down;' "";
alias 'scz'   'console_scroll_reset;' "";
bind "PageUp" "if(_display_console==0){prev_picture;}else{scu;}";
bind "PageDown" "if(_display_console==0){next_picture;}else{scd;}";
alias "musicplay"  "system 'mpc play'" "";
alias "musicpause" "system 'mpc pause'" "";

bind "Home" "0;";
bind "End" "$;";
bind "Backspace" "prev";

#alias "rdjpgcom" 'system "rdjpgcom" i:filename';

# offsetscan usage : need a mechanism for popping all images before.
#alias "offsetscan" "while(i:width<1){push offimage;_open_offset=_open_offset+1;reload;}"; # NEW
alias "offsetscan" "while(i:width<1){push '/home/dez/mostro.jpg';stdout _open_offset ;_open_offset=_open_offset+1;reload;}"; # NEW
#This is a FIM initialization file. 
#Without one of these FIM is nothing.
#So feel free to modify it, but with caution! 

.SH NOTES
This manual page is incomplete: a number of topics, as type conversions, or operator precedence, or exact command usage is left unspecified.
Moreover, the conditions for autocommands execution are not fully specified.
Also a formal description of the various one-line commands, as well as an extensive example list is needed.
.SH SEE ALSO
fim(1), regex(1).
.SH AUTHOR
Michele Martone <dezperado _CUT_ autistici _CUT_ org>
.SH COPYRIGHT
See fim(1).


